<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>微前端实践 - nodepie</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/qinyang912"><span>Github</span></a></li><li><a href="/atom.xml"><span>RSS</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="cover.jpg"><div class="post-title"><h1 class="title">微前端实践</h1><ul class="meta"><li><i class="icon icon-author"></i>Qin Yang</li><li><i class="icon icon-clock"></i>43 Minutes</li><li><i class="icon icon-calendar"></i>March 2, 2020</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>日事清的web端从诞生之初就一直用的backbone进行开发，当时的包管理器还用的require.js，构建方案还是grunt。后来在2016年，我们把构建方案换成了webpack，但是考虑到整个团队的学习成本，也考虑到项目的稳定性，再加上为了快速上线，视图框架还是用的Backbone，这个架构也就一直用到现在。</p>
<p>我们也鼓励团队成员用vue开发新的项目，在对比backbone和vue的开发效率的时候，我们发现，vue的效率高的不止一点点，且开发体验要比backbone好太多，所以什么时候能把backbone换成vue一直是我们的心愿。但没有业务场景，且现在项目又稳定，我们是绝不可能轻易迈出这一步的。</p>
<p>机会出现在了2019年10月份，日事清web端准备大版本迭代，新版的设计图和之前的几乎完全不一样，新增了非常多的功能，已有功能也做了非常多的优化。经过讨论，我们决定对项目进行重构，重构就意味着我们有机会引入新技术。</p>
<p>但是此次重构有点特别，如果用过日事清的小伙伴应该知道，日事清分：日程，计划，笔记，应用，公司5个模块，但日程不参与此次重构，其他几个模块都需要分批进行重构，且最好是重构完一个模块，就上线一个模块。也就是说，如果我们想用vue来重构，必须要backbone和vue共存一段时间，然后再逐步把所有的backbone替换掉。</p>
<p><img src="rishiqing-module.jpg" alt="rishiqing-module.jpg"></p>
<p>最终我们决定引入微前端的架构，选择微前端可以非常好的解决这次重构遇到的问题：</p>
<ol>
<li>多个技术框架可共存使用，即使用vue不会对已有的backbone造成影响</li>
<li>可灵活的进行渐进式重构</li>
<li>进行重构的模块可以选择新的技术方案</li>
<li>后续重构的模块可独立发布</li>
</ol>
<h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><p>目前业界比较成熟的微前端方案主要是两种：iframe和singleSpa</p>
<p>iframe:</p>
<p>日事清之前有部分功能就是用iframe的方式嵌套在页面里的，但是这种嵌套的方式有很多限制：</p>
<ol>
<li>iframe内部的事件不能冒泡出来，导致很多交互都需要postMessage来对接，非常麻烦</li>
<li>ifame内部的全局弹窗不能全尺寸弹出，影响用户体验</li>
</ol>
<p>singleSpa:</p>
<p>开源项目<a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>，它的实现思路是：一个主应用和若干个子应用</p>
<p>​    主应用：负责子应用的注册、挂载和销毁</p>
<p>​    子应用：提供三个接口：bootstrap, mount, unmount供主应用调用</p>
<p>我们最终选择了singleSpa，主要原因是：</p>
<ol>
<li>子应用可以挂载在主应用的某个元素下面，可以和主应用共享一个执行环境</li>
<li>子应用的注册、挂载和销毁逻辑相对简单，如果放到脚手架里，所有子项目都可以共用</li>
</ol>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="路由管理-amp-子应用注册"><a href="#路由管理-amp-子应用注册" class="headerlink" title="路由管理 &amp; 子应用注册"></a>路由管理 &amp; 子应用注册</h2><p>我们需要管理3部分的路由：</p>
<ol>
<li>原有的backbone路由</li>
<li>singleSpa注册子应用的路由</li>
<li>子应用内部的路由</li>
</ol>
<p>我们原有的backbone的路由的对应关系是这样的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">模块</th>
<th>路由</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">日程</td>
<td>/app/todo</td>
</tr>
<tr>
<td style="text-align:left">计划</td>
<td>/app/kanban</td>
</tr>
<tr>
<td style="text-align:left">笔记</td>
<td>/app/doc</td>
</tr>
<tr>
<td style="text-align:left">应用</td>
<td>/app/application</td>
</tr>
<tr>
<td style="text-align:left">公司</td>
<td>/app/company</td>
</tr>
</tbody>
</table>
<p>这次除了日程模块之外，其他几个模块都会重构，也即其他几个模块的路由都不走backbone。</p>
<p>singleSpa支持通过路由的方式来判断是否挂载子应用，且引入singleSpa并不会影响backbone的路由的正常工作，所以我们只用把日程之外的其他几个模块的路由从backbone移除，然后把其他几个模块当做子应用注册到singleSpa即可。</p>
<p>以注册笔记模块为例，下面是注册部分的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> singleSpa <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lifecycleFn = [<span class="string">'bootstrap'</span>, <span class="string">'unmount'</span>, <span class="string">'mount'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTAINER_CACHE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一下子应用暴露的方法，至少保证生命周期函数是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapLifecycle</span> (<span class="params">life = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!life) life = &#123;&#125;;</span><br><span class="line">  lifecycleFn.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!life[method] || <span class="keyword">typeof</span> life[method] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      life[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> life;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span> (<span class="params">containerId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  container.id = containerId;</span><br><span class="line">  <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 应用名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>options 可选配置参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.containerId 元素容器的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.appPath 元素的路径，如果不传则默认为 /app/$&#123;name&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerApplication</span> (<span class="params">name, options</span>) </span>&#123;</span><br><span class="line">  singleSpa.registerApplication(name, loadApp(name), (location) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> appPath = options.appPath || <span class="string">`/app/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> active = location.pathname.startsWith(appPath);</span><br><span class="line">    <span class="keyword">if</span> (active) &#123;</span><br><span class="line">      <span class="comment">// 这里之所以这样做，是因为这个方法可能会被执行多次，为了防止container重复创建</span></span><br><span class="line">      <span class="keyword">if</span> (!CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        <span class="keyword">const</span> container = createContainer(options.containerId);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">        CONTAINER_CACHE[name] = container;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        CONTAINER_CACHE[name].parentElement.removeChild(CONTAINER_CACHE[name]);</span><br><span class="line">      &#125;</span><br><span class="line">      CONTAINER_CACHE[name] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    containerId: options.containerId</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注册笔记</span></span><br><span class="line">  registerApplication(<span class="string">'doc'</span>, &#123;</span><br><span class="line">    containerId: <span class="string">'doc-container'</span></span><br><span class="line">    appPath: <span class="string">'/app/doc'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  singleSpa.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当有路由变化的时候，singleSpa.registerApplication的第三个参数就会执行，然后判断路径是否是<code>/app/doc</code>开头的，如果是，则说明需要挂载笔记这个子应用。</p>
<p>在判断可以挂载子应用之后，主应用会创建一个Div容器，然后把这个容器传给子应用，子应用在执行挂载逻辑的时候，就会把整个应用都挂载在这个Div里面。</p>
<p>大家可能有注意到，代码里有用到一个全局变量System，这个是<a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">systemjs</a>暴露出来的，用来加载线上的js模块，后面讲怎么发布的时候会详细讲到。</p>
<p>在笔记子应用里需要暴露出single-spa挂载和销毁要用到的三个周期函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 启动函数</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-empty-function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  vueContainer = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;props.containerId&#125;</span>`</span>)</span><br><span class="line">  el.appendChild(vueContainer.$el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vueContainer) &#123;</span><br><span class="line">    vueContainer.$destroy()</span><br><span class="line">    <span class="keyword">if</span> (vueContainer.$el.parentElement) &#123;</span><br><span class="line">      vueContainer.$el.parentElement.removeChild(vueContainer.$el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在mount的时候初始化子应用的入口vue组件，并挂载到主应用那边传过来的一个div下面</p>
<p>在unmount的时候，执行$destroy，销毁应用</p>
<p>上面提到，我们需要管理3部分路由，最后一部分子应用内部的路由，就在这里mount的时候直接初始化了。之后只要在这个子应用里的路由跳转，都能经过vue-router进行处理。</p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>数据层是一个非常庞大且复杂的话题，限于篇幅，简单讲一下我们的数据层是怎么设计的.</p>
<h3 id="打通backbone和vue之间的数据"><a href="#打通backbone和vue之间的数据" class="headerlink" title="打通backbone和vue之间的数据"></a>打通backbone和vue之间的数据</h3><p>在考虑数据层怎么设计的时候，遇到的第一个问题是：我们的主应用是基于backbone开发的，数据管理是backbone提供的collection和model，但是我们的子应用是用vue进行开发，要怎么打通backbone和vue之间的数据进行共享。</p>
<p>在解决这个问题的时候，我们都有一个共识，首先需要保证原有的backbone的数据稳定，代码能不动的尽量不动，等所有模块都用vue重构完了之后，让backbone自然而然的退役。经过分析之后，我们发现主应用里需要共享的就这么几类数据：</p>
<ol>
<li>用户的基础数据</li>
<li>组织架构数据</li>
<li>websocket实时推送数据</li>
</ol>
<p>用户基础数据和组织架构数据每个子应用都会用到，为了避免子应用再调接口去获取这些数据，需要想办法把这两个数据共享出去</p>
<p>主应用里有用到websocket来接收实时数据，拆分之后的子应用也需要用到websocket，我们最终决定只在主应用里初始化webscoket连接，不在各子应用再建立webscoket，原因如下：</p>
<ol>
<li>需要建立websocket的子应用比较多，如果每个都单独建立，会增加服务器的压力</li>
<li>子应用会随着路由的变化而挂载或者销毁，会导致频繁的建立websocket</li>
<li>在主应用和子应用之间嫁接一个事件总线，当主应用收到实时数据之后，就在这个事件总线上触发一个事件，子应用只要挂载之后就订阅这个事件，这样子应用也能及时收到实时数据</li>
</ol>
<p>基于上面的考虑，我们设计了一个中间层，代码大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'eventemitter3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageClient = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础数据</span></span><br><span class="line"><span class="keyword">const</span> BasicData = &#123;</span><br><span class="line">  USER_INFO: &#123;&#125;,</span><br><span class="line">  USER_TREE: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setBasicData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(BasicData, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBasicData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BasicData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息客户端</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getMessageClient</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> messageClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往消息客户端发送消息(ws实时消息)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  messageClient.emit(<span class="string">'message'</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主应用在初始化了之后，调用<code>setBasicData</code>把用户基础数据和组织架构数据放到BasicData里缓存起来，每个子应用初始化之后，只要调用<code>getBasicData</code>，即可获取到基础数据，而不用再调接口</p>
<p>主应用在收到websocket数据之后，调用<code>sendMessage</code>往事件总线上触发一个<code>message</code>事件，子应用只要通过<code>getMessageClient</code>拿到这个消息客户端，然后订阅<code>message</code>事件，即可收到实时数据，子应用销毁之后，取消订阅即可</p>
<h3 id="vue内部的数据管理"><a href="#vue内部的数据管理" class="headerlink" title="vue内部的数据管理"></a>vue内部的数据管理</h3><p>子应用里有用到<a href="https://rxdb.info/" target="_blank" rel="noopener">Rxdb</a>做数据管理，这里就不展开了，有机会今后可以另外写一篇</p>
<h2 id="组件-amp-代码复用"><a href="#组件-amp-代码复用" class="headerlink" title="组件&amp;代码复用"></a>组件&amp;代码复用</h2><p>引入微前端架构之后，面临着一个非常大的问题：所有子应用都被拆分成独立的仓库进行独立维护了，那怎么进行代码和组件的复用?</p>
<h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>好在我们从19年初就有意识的在开发我们内部的组件库，基于业务需要，我们在开发自己的组件库的时候把组件分成了两类：</p>
<ol>
<li>基础组件</li>
<li>业务组件</li>
</ol>
<p>基础组件主要包括: button, icon, popover, modal, tree这种通用组件</p>
<p>业务组件主要包括：成员选择器，日期选择器这种业务强相关的组件</p>
<p>我们的子应用都是基于我们自己的组件库进行开发的，组件库支持按需引入，尽量减少代码体积</p>
<h3 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h3><p>vue-cli的脚手架在我们这次重构过程中起到了非常大的作用，它的作用仅次于我们的组件库。</p>
<p>用过vue-cli的同学应该都知道，vue-cli和普天之下的其他cli一样，支持代码模板，支持preset，也支持自定义插件。为了方便团队成员使用vue，我们在18年就开始开发自己的vue-cli插件，可快速初始化我们内部需要的各种项目。</p>
<p>使用脚手架的收益会逐年增大，尤其是当团队里需要开发的应用越来越多，收益会越来越大。</p>
<h4 id="快速初始化项目"><a href="#快速初始化项目" class="headerlink" title="快速初始化项目"></a>快速初始化项目</h4><p>我们把一个微应用需要用到的基础代码全部放到vue-cli插件里的generator里，使用插件，可快速创建一个满足我们自己需求的微应用。</p>
<h4 id="webpack配置统一管理"><a href="#webpack配置统一管理" class="headerlink" title="webpack配置统一管理"></a>webpack配置统一管理</h4><p>自定义vue-cli插件的另一个好处就是，我们可以统一管理所有项目的webpack配置。</p>
<p>使用vue-cli初始化的项目，在项目的根目录下都会有一个vue.config.js，在这个文件里可以扩展webpack的配置。但是我们为了方便统一维护webpack，把所有需要扩展的webpack配置全部放到插件里去完成。</p>
<p>比如：</p>
<ol>
<li>统一给所有css变量加上一个默认值，这样就算不支持css变量的浏览器，也可以用默认值</li>
<li>统一的babel配置</li>
<li>统一微应用的构建方案</li>
</ol>
<h4 id="基础代码复用"><a href="#基础代码复用" class="headerlink" title="基础代码复用"></a>基础代码复用</h4><p>由于所有项目里都装了我们自己开发的vue-cli插件，所以我们把所有需要复用的代码，全部放到vue-cli里的lib文件夹下，然后在插件里配置一个webpack的alias指向这个文件夹，方便在项目里引用</p>
<h3 id="自建npm镜像"><a href="#自建npm镜像" class="headerlink" title="自建npm镜像"></a>自建npm镜像</h3><p>不是所有的npm包都能发布到npm官方镜像的，为了满足团队内部需要发布npm包的需求，我们用<a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a>搭建了自己的npm镜像，到现在用了一年多了，一直很稳定。</p>
<p>自建的npm镜像，也给我们复用代码提供了非常多的帮助，我们有很多功能都是以npm包发布在自己的npm镜像里，比如：</p>
<ol>
<li>编辑器相关的</li>
<li>前面提到的组件库</li>
<li>基于开源项目修改之后发布的包，以满足我们自己的需求</li>
</ol>
<h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><p>为了避免应用之间的样式影响，我们分别从规范和技术上做了规避</p>
<h3 id="BEM规范"><a href="#BEM规范" class="headerlink" title="BEM规范"></a>BEM规范</h3><p>所有应用，包括我们的组件库，必须使用<a href="http://getbem.com/" target="_blank" rel="noopener">BEM</a>规范进行样式开发，这样在写代码的时候，就已经尽量避免了样式的相互影响。</p>
<h3 id="动态添加-移除样式"><a href="#动态添加-移除样式" class="headerlink" title="动态添加/移除样式"></a>动态添加/移除样式</h3><p>我们的子应用在打包的时候，并不会单独把css文件提取出来，考虑到css的体积并不大，css会随着js文件一起发布，后面插入到页面的style标签里.</p>
<p>我们改造了一下vue官方提供的vue-style-loader，支持往style标签上生成自定义的属性.</p>
<p><img src="single-spa-id.jpg" alt="single-spa-id"></p>
<p>我们会往style标签上添加一个名为: data-single-spa-id的属性，它的值是一个每次构建的时候都会生成的随机值，而这个随机值会通过webpack的define插件，定义成一个全局变量，这样我们在子应用里也能拿到这个随机值，然后就能在子应用挂载和销毁的时候动态的添加/移除样式，进一步避免样式影响。动态添加/移除的代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'./i18n'</span></span><br><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"><span class="keyword">let</span> styleCache</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="built_in">document</span>.querySelector(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">if</span> (styleCache) &#123;</span><br><span class="line">      styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">        head.appendChild(style)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 移除掉所有的style</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    styleCache = [...document.querySelectorAll(<span class="string">`style[data-single-spa-id="<span class="subst">$&#123;SINGLE_SPA_ID&#125;</span>"]`</span>)]</span><br><span class="line">    styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">      style.parentNode.removeChild(style)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  addStyle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  removeStyle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，样式的动态添加/移除是和子应用的挂载和销毁逻辑在一起的，代码里的<code>SINGLE_SPA_ID</code>就是通过webpack的define插件定义的全局变量</p>
<h2 id="构建和发布"><a href="#构建和发布" class="headerlink" title="构建和发布"></a>构建和发布</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="构建SystemJs能识别的包"><a href="#构建SystemJs能识别的包" class="headerlink" title="构建SystemJs能识别的包"></a>构建SystemJs能识别的包</h4><p>前面我们提到systemJs，systemJs是一个前端的包管理器，它支持加载线上的js代码，但是对发布的代码有一些要求，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.register([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>需要用System.register对代码进行包裹</p>
<p>我们找到了一个webpack插件：<a href="https://github.com/CanopyTax/webpack-system-registe" target="_blank" rel="noopener">webpack-system-register</a>，它会自动给入口文件包裹上System.register，但是这个插件已经很久没有更新了，且这个插件也有些问题，比如：</p>
<ol>
<li>如果webpack的entry里的某一项是个数组，他无法正常处理</li>
<li>有的时候无法正常识别入口文件，导致把非入口代码也给加上了System.register</li>
</ol>
<p>我们自己对这个插件进行了修改，发布在了自己的npm镜像里</p>
<h4 id="对html文件的处理"><a href="#对html文件的处理" class="headerlink" title="对html文件的处理"></a>对html文件的处理</h4><p>由于子应用发布时候不需要Html文件，所以我们在构建的时候，需要把html相关的插件删掉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api.chainWebpack(<span class="function">(<span class="params">webpackChain</span>) =&gt;</span> &#123;</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'html'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>Systemjs可以自动识别html代码里定义的<code>systemjs-importmap</code>，如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"systemjs-importmap"</span> <span class="attr">src</span>=<span class="string">"importmap.json"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>importmap.json</code>需要是一个线上的json文件地址，其数据格式大致如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"imports"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: <span class="string">"https://cdn/xxx.xxx.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个json文件有什么作用呢，需要结合我们在前面讲到子应用注册的一部分代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个loadApp方法，当你调用<code>loadApp(&#39;doc&#39;)</code>的时候，SystemJs会找到那个json文件里对应的子应用的对应的线上js代码地址，然后加载，最后把js代码暴露成一个变量app，这个app需要暴露我们前面提到的single-spa挂载和销毁子应用需要的3个方法:bootstrap, mount, unmount</p>
<p>所以我们现在的发布逻辑就变得很清晰了，只要想办法，在应用构建之后，把构建出来的文件推到CDN上面，同时修改<code>importmap.json</code>文件里对应的子应用的地址即可</p>
<p>基于此，我们自己开发了一个<code>update-server</code>用来负责子应用的发布和更新，子应用在发布的时候，会调<code>update-server</code>提供的接口，把json文件里的地址更新到最新版</p>
<h2 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h2><p>写到这里，还只字未提我们是怎么开发的。</p>
<p>大部分的微前端架构都会面临一个问题：微前端大多是一个主应用 + 若干个子应用的模式，子应用基本上都会依赖主应用提供的一些环境和数据，就像前面说的，我们为什么要打通backbone和vue之间的数据，也是这个原因，也就是说，如果没有主应用的环境，子应用就跑不起来，而如果要开发子应用还必须启动主应用，在开发体验上必然会大打折扣。</p>
<p>所以我们的解决方案是，在vue-cli插件里模拟主应用的环境。</p>
<p>前面有提到，在vue-cli插件里有一个lib文件夹，专门用来放需要复用的代码。前面提到的为了打通backbone和vue之间的数据而开发的中间层，需要在vue-cli插件里写一些代码来封装这个中间层的代码。</p>
<p>为什么要这么要封装呢？这样可以做到子应用对环境的无感，子应用不用在意自己是不是在主应用里运行，子应用只用调用这个封装之后的接口，至于运行环境，在封装这一层去判断。</p>
<p>这层封装做了这些事：</p>
<ol>
<li><p>如果在主应用里运行，则直接调用中间层提供的缓存数据，直接返回给子应用</p>
</li>
<li><p>如果子应用是单独在运行，则需要去调用相关的接口，拉取到数据，然后返回给子应用</p>
</li>
</ol>
<p>封装那一层做的事情，对子应用是无感的，子应用只管调封装之后的接口就行</p>
<h3 id="如何切换调试环境"><a href="#如何切换调试环境" class="headerlink" title="如何切换调试环境"></a>如何切换调试环境</h3><p>前面我们通过在vue-cli插件里做了一层封装，让子应用可以脱离主应用进行开发，但是难免有的时候是需要接入到主应用里进行调试的，那这个时候怎么办呢？</p>
<p>我们利用环境变量进行区分，vue-cli支持在项目的根目录下定义<code>.env.</code>开头的文件，可以直接在这些文件里写环境变量，</p>
<p>在开发子应用的时候，只要在<code>.env.local</code>里配置上:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RISHIQING_SINGLE_SPA=false # 可配置为true，构建在主应用里调试需要的代码</span><br></pre></td></tr></table></figure>
<p>当<code>RISHIQING_SINGLE_SPA</code>为true的时候，就会构建出一个适合SystemJs引入的js包，这样方便在主应用里调试</p>
<p>当<code>RISHIQING_SINGLE_SPA</code>为false的时候，也是默认值，表示子应用需要独立开发</p>
<p>除了前面说的获取基础数据的方式不一样之外，这两种环境最大的区别就是，<code>RISHIQING_SINGLE_SPA</code>为true的时候，不会构建出html，而<code>RISHIQING_SINGLE_SPA</code>为false的时候，由于需要独立调试，则需要构建html。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，关于日事清的微前端实践先写到这里了，有很多章节其实是很复杂的，但是要在一篇文章里写完，还是有难度。微前端不是银弹，适合的才是最好的。</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><h2 id="为什么没有共享基础库，比如vue-axios-vuex等"><a href="#为什么没有共享基础库，比如vue-axios-vuex等" class="headerlink" title="为什么没有共享基础库，比如vue, axios, vuex等?"></a>为什么没有共享基础库，比如vue, axios, vuex等?</h2><p>开始是有做相关开发的，但是在开发过程中，我们发现，不同的子应用，依赖的版本号会不同，如果强制统一，很容易出问题。但是这样也带来了一个问题，就是会增加代码体积。我们会在后面各子应用逐渐稳定之后，想办法进行复用</p>
<h2 id="项目拆分成微前端之后，如果进行代码管理？"><a href="#项目拆分成微前端之后，如果进行代码管理？" class="headerlink" title="项目拆分成微前端之后，如果进行代码管理？"></a>项目拆分成微前端之后，如果进行代码管理？</h2><p>微前端架构虽然给前端项目带来了更多可能性，但也带来了维护上的困难。就拿我上面提到的vue-cli插件，我们现在的子应用有十几个，一旦插件有更新，就得在十几个项目里进行更新，非常麻烦。后续我们可能会引入<a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a>再把所有微应用放到一个仓库里进行管理，来解决包的依赖问题。俗话说分久必合，合久必分，大概就是这个理吧。</p>
<h2 id="对这次重构有什么想说的？"><a href="#对这次重构有什么想说的？" class="headerlink" title="对这次重构有什么想说的？"></a>对这次重构有什么想说的？</h2><p>业务的发展是技术的助推剂，一切技术的更新都源于对业务场景的思考</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/singleSpa/">singleSpa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a><span class="tag-list-count">1</span></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2020/03/29/我6年的远程工作/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/05/29/code-review/"><i class="icon icon-arror-right"></i></a></li></ul><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><div><div id="gitalk-container" style="max-width:800px; margin: auto; padding: 0 36px"></div></div><script>var gitalk = new Gitalk({
  clientID: '2638ec070f57a82545cc',
  clientSecret: 'b0aeaed2b37065dffdc1ac48133d8a950414e6c4',
  accessToken: 'dad4b0a525e1aacd191f17395e9e97f984113e0a',
  id: window.location.pathname.replace(/\/$/, '').replace(/^\//, '').replace(/\//g, '-').substr(0, 40),
  repo: 'nodepie',
  owner: 'qinyang912',
  admin: ['qinyang912'],
  distractionFreeMode: true
})
gitalk.render('gitalk-container')</script><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/qinyang912" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.zhihu.com/people/qin-yang-22" title="知乎" target="_blank"><i class="icon icon-zhihu"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2021 nodepie<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>