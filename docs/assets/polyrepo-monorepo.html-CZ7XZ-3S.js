import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as r,c as l,a as s,b as n,d as a,e as o}from"./app-UHqMiyo5.js";const i="/assets/posts/polyrepo-monorepo/polyrepo-vs-monorepo.png",c="/assets/posts/polyrepo-monorepo/webpack-alias-eslint.png",u="/assets/posts/polyrepo-monorepo/vetur-hover-1.png",d="/assets/posts/polyrepo-monorepo/vetur-hover-2.png",m={},v=s("p",null,"所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。",-1),k={href:"https://github.com/vuejs/vue-next",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/babel/babel",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/npm/cli/releases",target:"_blank",rel:"noopener noreferrer"},g=o('<h2 id="monorepo-vs-polyrepo" tabindex="-1"><a class="header-anchor" href="#monorepo-vs-polyrepo"><span>monorepo vs polyrepo</span></a></h2><h3 id="架构对比" tabindex="-1"><a class="header-anchor" href="#架构对比"><span>架构对比</span></a></h3><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从这张架构图可以看出polyrepo和monorepo最大的区别:</p><p>polyrepo是一个项目一个仓库，且每个项目都有独立的构建工具</p><p>monorepo是多个项目都在同一个仓库，且每个项目共享同一套构建工具</p><h3 id="polyrepo的缺陷" tabindex="-1"><a class="header-anchor" href="#polyrepo的缺陷"><span>polyrepo的缺陷</span></a></h3><p>polyrepo如前文所说，把每个项目都分散到不同的仓库，当项目的数据急剧增加之后，会给整个团队的代码管理带来巨大的负担.</p><h4 id="代码无法方便的同步更新" tabindex="-1"><a class="header-anchor" href="#代码无法方便的同步更新"><span>代码无法方便的同步更新</span></a></h4><p>构建方案的更新往往是需要所有项目同步更新的，或者某些package.json里的依赖包也是需要同步更新，而这些基础代码都是分散在各个项目的仓库里，为了保持所有项目的统一更新，我们只能一个一个的npm install, 或者一个一个仓库的改代码，然后提交到线上，触发ci/cd，这一套组合拳打下来估计一天时间就过去了</p><h4 id="多项目更新麻烦" tabindex="-1"><a class="header-anchor" href="#多项目更新麻烦"><span>多项目更新麻烦</span></a></h4><p>有的需求涉及到同时修改多个项目，在开发的时候，不得不在每个项目单独开分支，单独提交合并，单独触发ci/cd，非常麻烦，而且有的时候修改的项目过多，还容易忘记更新某些项目的代码.</p><h4 id="项目之间的引用不方便" tabindex="-1"><a class="header-anchor" href="#项目之间的引用不方便"><span>项目之间的引用不方便</span></a></h4><p>如果项目相互有依赖，只能各种npm link关联起来，然后进行调试. 有时候如果依赖关系变得复杂, npm link也会变得特别麻烦.</p><p>比如有这么个依赖关系:</p><p>项目A -&gt; 项目B -&gt; 项目C</p><p>这时候为了正常调试，有可能你得做这些npm link：</p><ol><li>在项目A里npm link 项目B，npm link 项目C</li><li>在项目B里npm link 项目C</li></ol><p>这么做太麻烦了，而且有的时候很容易把线上的包和本地npm link的包搞混</p><h3 id="monorepo的优点" tabindex="-1"><a class="header-anchor" href="#monorepo的优点"><span>monorepo的优点</span></a></h3><p>monorepo可以很好的规避上面提到的polyrepo的缺陷</p><p>由于所有代码都在一个仓库里，要同步基础构建和基础代码变得非常容易，当涉及到修改多个项目的时候，也不用再分开提交代码了</p><p>借助npm workspace自带的特性，可以自动的把依赖的项目给link到node_modules下面，从而可以减少npm link的使用</p><p>除了解决polyrepo里提到的缺陷，monorepo还有其他优点.</p><h4 id="所有项目代码一目了然" tabindex="-1"><a class="header-anchor" href="#所有项目代码一目了然"><span>所有项目代码一目了然</span></a></h4><p>所有项目整合到一个仓库之后，后续对仓库的修改和更新都会更加聚合，每个人都能非常方便的看到每个项目的代码的变更情况，更有利于大家的协作。</p><p>且每个人的本地克隆都能非常方便的保持每个项目的最新代码，更容易避免由于某些项目的代码延后带来的bug。</p><h4 id="代码风格更加统一" tabindex="-1"><a class="header-anchor" href="#代码风格更加统一"><span>代码风格更加统一</span></a></h4><p>当所有项目都在一个仓库之后，所有项目都能共享同一份eslint配置，指定的commit lint规则也能共享，这样就可以保证所有项目的代码都是符合统一的eslint规范，commit message也是符合规范的</p><h3 id="没有100-的合适" tabindex="-1"><a class="header-anchor" href="#没有100-的合适"><span>没有100%的合适</span></a></h3><p>对比了polyrepo的缺点和monorepo的优点之后，你会发现好像polyrepo完全不如monorepo，但俗话说得好，没有万能银弹，合适的才是最好的，polyrepo也有他适合的场景.</p><ol><li>当项目不是很多的时候</li><li>当项目采用的技术方案和构建方案不是特别相似的时候.</li><li>当每个项目的更新都需要及其灵活的时候</li></ol><p>以上三种情况还是用polyrepo比较合适，monorepo会极大的限制灵活性</p><h2 id="monorepo落地" tabindex="-1"><a class="header-anchor" href="#monorepo落地"><span>monorepo落地</span></a></h2><p>在npm还不支持workspace之前，管理monorepo的方案基础主要有这些:</p><ol><li>lerna https://github.com/lerna/lerna</li><li>Yarn workspace https://yarnpkg.com/features/workspaces</li><li>Pnpm workspace https://pnpm.io/workspaces</li></ol>',36),f={href:"https://github.com/lerna/lerna/issues/2703",target:"_blank",rel:"noopener noreferrer"},y=o(`<p>yarn和pnpm的workspace没有仔细研究过，可以自行查看</p><p>在npm@7.0.0发布之后（最近已经更新到npm@8.1.3），npm也支持了workspace，但由于npm的workspace还处在比较早期的阶段，部分monorepo需要的特性都还不支持. 所以我们最终采用的方案是npm@8.x和lerna配合的方案:</p><p>npm负责做monorepo的最基础管理，比如依赖安装处理，自动link等</p><p>lerna负责monorepo的一些常用功能，比如对比有哪些项目发生了变更，自动更新version，自动生成changelog等</p><p>以下内容会涉及到npm workspace的使用，如果不熟悉，可以提前了解: https://docs.npmjs.com/cli/v7/using-npm/workspaces/</p><h3 id="项目搭建" tabindex="-1"><a class="header-anchor" href="#项目搭建"><span>项目搭建</span></a></h3><p>搭建一个monorepo项目，主要考虑两个环境的问题: 开发环境、构建环境。</p><p>开发环境需要考虑的问题：</p><ol><li>IDE(VS Code)如何更好的辅助开发</li><li>开发工具如何只在monorepo项目的根目录下配置，微应用都能从根目录共享</li><li>提高开发效率</li></ol><p>构建环境需要考虑的问题：</p><ol><li>如何只对变更的代码做lint检查，提高lint速度</li><li>如何只对变更的项目做构建和发布，提高发布速度</li></ol><h4 id="eslint" tabindex="-1"><a class="header-anchor" href="#eslint"><span>eslint</span></a></h4><h5 id="各个微应用共享babel配置" tabindex="-1"><a class="header-anchor" href="#各个微应用共享babel配置"><span>各个微应用共享babel配置</span></a></h5><p>eslint的配置是支持覆盖的, 假设有如下目录结构:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>.
├── monorepoRoot
│   ├── packages
│       ├── project-a
│           ├── .eslintrc.js
│       ├── project-b
│           ├── .eslintrc.js
│   ├── .eslintrc.js
│   ├── babel.config.js
│   ├── package.json
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写在monorepoRoot/.eslintrc.js里的eslint配置，都会被project-a/.eslintrc.js和project-b/.eslintrc.js继承。但如果eslint需要使用@babel/eslint-parser作为parser的话就会出现一点小问题，在不做处理的情况下，如果在monorepoRoot下执行:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">npm</span> run lint <span class="token parameter variable">-w</span> project-a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>@babel/eslint-parser会报找不到babel配置的问题，@babel/eslint-parser官方已经提供了解决方案:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">parser</span><span class="token operator">:</span> <span class="token string">&quot;@babel/eslint-parser&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">parserOptions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">babelOptions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">rootMode</span><span class="token operator">:</span> <span class="token string">&quot;upward&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在各个微应用里的.eslintrc.js配置，把parserOptions.babelOptions.rootMode配置为upward即可，这样只要在monorepoRoot下面有babel的配置即可，不用每个微应用添加babel的配置文件. 对应到这个目录结构，只要在project-a和project-b项目下的.eslintrc.js里添加上这个配置即可</p><p>参考: https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser#additional-parser-configuration</p><h5 id="适配vue项目" tabindex="-1"><a class="header-anchor" href="#适配vue项目"><span>适配vue项目</span></a></h5><p>如果你的微应用是vue-cli初始化的项目，你会发现所有通过alias引入的代码在vs code的eslint都会报</p><p>Unable to resolve的错误:</p><figure><img src="`+c+'" alt="webpack-alias-eslint" tabindex="0" loading="lazy"><figcaption>webpack-alias-eslint</figcaption></figure>',25),j={href:"https://github.com/vuejs/eslint-config-airbnb",target:"_blank",rel:"noopener noreferrer"},_=o(`<div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;@vue/cli-service/webpack.config.js&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参考链接: https://github.com/vuejs/eslint-config-airbnb/blob/cfa98d5f95be585d72e092f783178518cf3c0aa5/index.js#L10</p><p>在普通的vue-cli生成的项目没有问题，上面这行代码没有问题，能通过项目下的vue.config.js解析出webpack配置，然后eslint就能正常解析webpack的alias配置.</p><p>但在monorepo会有问题, 我们来看看@vue/cli-service/webpack.config.js里的代码:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> service <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token constant">VUE_CLI_SERVICE</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>service <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VUE_CLI_API_MODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> Service <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./lib/Service&#39;</span><span class="token punctuation">)</span>
  service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VUE_CLI_CONTEXT</span> <span class="token operator">||</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  service<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VUE_CLI_MODE</span> <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">resolveWebpackConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，如果没有指定process.env.VUE_CLI_CONTEXT环境变量, 会默认从process.cwd()指定文件夹去找到vue.config.js文件，然后解析出对应的webpack配置，在monorepo场景下, 这个process.cwd()取得的值是monorepo的根目录，不是微应用所在的路径，所以我们需要对每个微应用的.eslintrc.js配置做一些调整:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">settings</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&#39;import/resolver&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;eslint-import-resolver-webpack&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">config</span><span class="token operator">:</span> require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;./eslint.webpack.config.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里面的eslint.webpack.config.js的代码为:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> Service <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;@vue/cli-service/lib/Service&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span>
service<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">resolveWebpackConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就能让eslint-import-resolver-webpack从微应用所在的根目录去解析webpack的配置了</p><h4 id="babel" tabindex="-1"><a class="header-anchor" href="#babel"><span>babel</span></a></h4><h5 id="babel的配置共享" tabindex="-1"><a class="header-anchor" href="#babel的配置共享"><span>babel的配置共享</span></a></h5><p>babel的配置也是可以实现只在monorepo的根目录维护一份配置文件，不用每个微应用都单独写同样的配置</p><p>官方文档: https://babeljs.io/docs/en/config-files#monorepos</p><p>可以配置rootMode参数为upward，即可告诉微应用在运行babel的时候，配置文件可以到monorepo的根目录寻找</p><p>但是需要注意，rootMode参数是一个Only allowed in Babel&#39;s programmatic options的参数, 也就是只允许在编程环境的配置项使用，比如webpack的babel-loader里使用，不能直接在babel.config.js里使用</p><p>参考: https://babeljs.io/docs/en/options#rootmode</p><h4 id="vetur" tabindex="-1"><a class="header-anchor" href="#vetur"><span>vetur</span></a></h4><p>vetur插件也对monorepo做了额外的支持. 在常规情况下, 我们是不需要在项目的根目录维护一个vetur.config.js文件的，在vs code安装了vetur插件之后，利用默认的配置即可获得足够的开发体验.</p><p>在使用monorepo之后就发现了一个问题:</p><figure><img src="`+u+`" alt="vetur-hover-1" tabindex="0" loading="lazy"><figcaption>vetur-hover-1</figcaption></figure><p>hover到一个引入的方法上面，无法提示这个方法的定义信息，尽管微应用里已经配置了jsconfig.json</p><p>这是因为vetur无法识别到这个微应用里的jsconfig.json文件，需要到monorepo下面的vetur.config.js里配置一个projects参数，告诉vetur，你的微应用在哪些文件夹下面:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">projects</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&#39;./packages/project-a&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+'" alt="vetur-hover-2" tabindex="0" loading="lazy"><figcaption>vetur-hover-2</figcaption></figure><p>这样再hover到引入的方法上面就可以正常显示了，按住cmd或者ctrl再点击，也可以跳转到对应的地方去</p><p>参考: https://vuejs.github.io/vetur/guide/setup.html#advanced</p><h4 id="按需构建和按需lint" tabindex="-1"><a class="header-anchor" href="#按需构建和按需lint"><span>按需构建和按需lint</span></a></h4><p>使用monorepo的模式，有一个比较大的问题就是所有项目都在一个仓库，在线上构建或者做lint检查的时候，如果只对一个项目做了修改，结果却要触发所有项目的构建和检查，这将是非常耗时的。所以需要辨别出来到底修改了哪些项目，只对改动的项目做构建和检查.</p><p>这也是我们要引入lerna的原因，npm workspace目前还不支持这些，估计将来也不会支持。</p><p>结合lerna的filter参数，比如scope, since等等，可以非常方便的检测出有哪些项目发生了变化，然后对应着只在这些变动的项目里执行对应的构建和lint命令，节省时间.</p><p>参考lerna的filter: https://github.com/lerna/lerna/tree/main/core/filter-options</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>monorepo把分散的大型的微应用项目给整合了起来，如果项目之间有非常多的共性，在维护和开发上会得到非常多的便利。</p>',34);function x(w,E){const e=t("ExternalLinkIcon");return r(),l("div",null,[v,s("p",null,[n("日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项目的发展，现在微应用的数量已经突破了30个，而polyrepo模式给代码管理带来了巨大的麻烦，尤其是每次要统一升级基础构建的时候，得挨个在每个微应用里执行同样的命令，想想同样的工作要重复几十遍，简直就是噩梦。所以如何更高效的管理微应用成了当前需要解决的一个痛点。在了解了"),s("a",k,[n("vue"),a(e)]),n(",、"),s("a",b,[n("babel"),a(e)]),n("等大型开源项目的解决方案之后，发现monorepo已经在社区有了比较广泛的应用。前端生态里的工具，比如eslint,、babel等也支持monorepo项目的配置，随着"),s("a",h,[n("npm@7.0"),a(e)]),n("的发布，workspace也成了npm的官方支持，所以现在做monorepo的改造也成了比较水到渠成的事情。")]),g,s("p",null,[n("lerna是一个第三方的解决方案，他不依赖任何的包管理工具，提供monorepo常用的命令，但是lerna在发布了4.0.0之后，就基本处于无人维护的状态(相关"),s("a",f,[n("issue"),a(e)]),n(")，PR和issue都没人处理，可能和包管理工具原生对monorepo做支持有关系吧.")]),y,s("p",null,[n("这是因为"),s("a",j,[n("@vue/eslint-config-airbnb"),a(e)]),n("里有内置eslint-import-resolver-webpack插件，但这个插件的config参数配置为:")]),_])}const V=p(m,[["render",x],["__file","polyrepo-monorepo.html.vue"]]),O=JSON.parse('{"path":"/posts/polyrepo-monorepo.html","title":"polyrepo -> monorepo","lang":"en-US","frontmatter":{"title":"polyrepo -> monorepo","tag":["工程化","monorepo"],"date":"2021-11-16T02:38:17.000Z","cover":"/assets/posts/polyrepo-monorepo/polyrepo-vs-monorepo.png","description":"所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。 日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项目的发展，现在微应用的数量已经突破了30个，而polyrepo模式给代码管理带来了巨大的麻烦，...","head":[["meta",{"property":"og:url","content":"https://nodepie.com/posts/polyrepo-monorepo.html"}],["meta",{"property":"og:site_name","content":"NodePie"}],["meta",{"property":"og:title","content":"polyrepo -> monorepo"}],["meta",{"property":"og:description","content":"所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。 日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项目的发展，现在微应用的数量已经突破了30个，而polyrepo模式给代码管理带来了巨大的麻烦，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://nodepie.com/assets/posts/polyrepo-monorepo/polyrepo-vs-monorepo.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://nodepie.com/assets/posts/polyrepo-monorepo/polyrepo-vs-monorepo.png"}],["meta",{"name":"twitter:image:alt","content":"polyrepo -> monorepo"}],["meta",{"property":"article:author","content":"QinYang"}],["meta",{"property":"article:tag","content":"工程化"}],["meta",{"property":"article:tag","content":"monorepo"}],["meta",{"property":"article:published_time","content":"2021-11-16T02:38:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"polyrepo -> monorepo\\",\\"image\\":[\\"https://nodepie.com/assets/posts/polyrepo-monorepo/polyrepo-vs-monorepo.png\\",\\"https://nodepie.com/assets/posts/polyrepo-monorepo/webpack-alias-eslint.png\\",\\"https://nodepie.com/assets/posts/polyrepo-monorepo/vetur-hover-1.png\\",\\"https://nodepie.com/assets/posts/polyrepo-monorepo/vetur-hover-2.png\\"],\\"datePublished\\":\\"2021-11-16T02:38:17.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"QinYang\\",\\"url\\":\\"https://nodepie.com\\"}]}"]]},"headers":[{"level":2,"title":"monorepo vs polyrepo","slug":"monorepo-vs-polyrepo","link":"#monorepo-vs-polyrepo","children":[{"level":3,"title":"架构对比","slug":"架构对比","link":"#架构对比","children":[]},{"level":3,"title":"polyrepo的缺陷","slug":"polyrepo的缺陷","link":"#polyrepo的缺陷","children":[]},{"level":3,"title":"monorepo的优点","slug":"monorepo的优点","link":"#monorepo的优点","children":[]},{"level":3,"title":"没有100%的合适","slug":"没有100-的合适","link":"#没有100-的合适","children":[]}]},{"level":2,"title":"monorepo落地","slug":"monorepo落地","link":"#monorepo落地","children":[{"level":3,"title":"项目搭建","slug":"项目搭建","link":"#项目搭建","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":10.05,"words":3014},"filePathRelative":"posts/polyrepo-monorepo.md","localizedDate":"November 16, 2021","excerpt":"<p>所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。</p>\\n<p>日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项目的发展，现在微应用的数量已经突破了30个，而polyrepo模式给代码管理带来了巨大的麻烦，尤其是每次要统一升级基础构建的时候，得挨个在每个微应用里执行同样的命令，想想同样的工作要重复几十遍，简直就是噩梦。所以如何更高效的管理微应用成了当前需要解决的一个痛点。在了解了<a href=\\"https://github.com/vuejs/vue-next\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">vue</a>,、<a href=\\"https://github.com/babel/babel\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">babel</a>等大型开源项目的解决方案之后，发现monorepo已经在社区有了比较广泛的应用。前端生态里的工具，比如eslint,、babel等也支持monorepo项目的配置，随着<a href=\\"https://github.com/npm/cli/releases\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">npm@7.0</a>的发布，workspace也成了npm的官方支持，所以现在做monorepo的改造也成了比较水到渠成的事情。</p>","autoDesc":true}');export{V as comp,O as data};
