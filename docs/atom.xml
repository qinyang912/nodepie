<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nodepie</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nodepie.com/"/>
  <updated>2018-05-30T01:36:25.000Z</updated>
  <id>https://nodepie.com/</id>
  
  <author>
    <name>Qin Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审查的正确姿势</title>
    <link href="https://nodepie.com/2018/05/29/code-review/"/>
    <id>https://nodepie.com/2018/05/29/code-review/</id>
    <published>2018-05-29T12:55:42.000Z</published>
    <updated>2018-05-30T01:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这是一个很久之前我就想在前端团队里推的一个事情，基于这么几个原因吧:</p><ol><li>一直以来，前端的代码审查都是我一个人在做，仅仅是关注大家对公共文件的修改，还有就是一些明显的逻辑问题，但其实大部分问题靠我一个人是发现不了的</li><li>我们自己总是容易陷入逻辑怪圈，在写代码的时候，很难发现自己的问题，但是看别人的代码的时候，往往比较挑剔，更容易发现别人的问题</li><li>促进我们的日常代码交流，吸收别人的优秀经验</li><li>当你知道某个人会审查你的代码的时候，你会更加严格要求自己</li><li>培养我们写出优秀代码的习惯，实现团队和个人的共同进步</li><li>我们需要更加关注代码的质量</li><li>Code Review可以有效的和重构相结合，给我们重构提供有力证据，推动我们进行重构工作</li></ol><h2 id="审查些什么"><a href="#审查些什么" class="headerlink" title="审查些什么"></a>审查些什么</h2><h3 id="审查清单"><a href="#审查清单" class="headerlink" title="审查清单"></a>审查清单</h3><p>如果你所在的团队和我们一样，也刚开始做Code Review，对代码审查到底应该审查些什么感到茫然，在网上搜了很多审查清单，发现非常零碎，也不知道哪些应该遵守，哪些不应该遵守。我的建议是，可以根据团队现有的开发情况，自己大概整理一份审查清单，也不用太完整，只要建立好完整的整理机制，在实施Code Review的过程中，自己总结提炼，以及修改维护之前的审查清单，这样在完善审查清单的过程中，也对健全团队的Code Review机制非常有帮助，让团队成员对新增的审查清单更加有认同感。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>到底要不要在代码审查的时候审查代码的格式，都各说不一。个人觉得代码格式不应该成为代码审查重要的关注点，格式问题，更多应该是靠开发者自己去发现解决，借eslint和sass-lint这类工具辅助，以及团队的代码规范，在提交审核之前就应该做到没有问题。代码审查本来就是为了审核功能的实现方式，代码的组织形式等等有没有更优解，但也不是说完全不关注，如果发现了格式问题，还是需要提出来。</p><h3 id="审查形式"><a href="#审查形式" class="headerlink" title="审查形式"></a>审查形式</h3><p>总体来说，代码审查有两种形式，小片段式和大规模式</p><h4 id="小片段式"><a href="#小片段式" class="headerlink" title="小片段式"></a>小片段式</h4><p>小片段式的代码审查，又称事前审查，是在代码合并到主分支之前就做的一种审查形式。如果发现了问题，在代码合并之前就会进行需改。这种形式可以直接在线上进行，代码提交者和审查者可完全线上进行交流。</p><h4 id="大规模式"><a href="#大规模式" class="headerlink" title="大规模式"></a>大规模式</h4><p>大规模式的代码审查，又称事后审查，团队可以每两个星期或者一个月组织一次大模块式的Code Review会议，大家在会上进行大规模的代码检视，提出问题并记录，之后可以以重构的方式来处理在会议上发现的问题.</p><h4 id="哪种形式更好"><a href="#哪种形式更好" class="headerlink" title="哪种形式更好"></a>哪种形式更好</h4><p>这两种形式各有各的好处，小片段式的方式让我们可以在审查较小代码量的情况下就能进行，并且可以在代码合并之前进行，这样可以提前发现一些bug，而大规模式可以几个人一起在会议上站在一个更高的层面去审核代码，彼此交流开发经验。我推荐是小片段式和大规模式相结合。</p><h3 id="怎么审查"><a href="#怎么审查" class="headerlink" title="怎么审查"></a>怎么审查</h3><h4 id="审查工具"><a href="#审查工具" class="headerlink" title="审查工具"></a>审查工具</h4><p>我们的代码管理用的github，github提供了非常棒的Code Review功能。利用github提供的pull request模板功能，让代码提交者根据这个模板去填写每次提交pull request需要的信息。另外github的markdown支持checkbox，我们可以把一些非常重要的，每次都需要检视的审查项列到模板里去，这样提交者就可以按照这个列表自己提前检查一遍，也可以减少审查者的工作。下面是我们现在用的一个模板<br><img src="pull_request_template.md.png" alt="pull request 模板"><br>前面6个checkbox，是提交者每次都必须自查一遍，然后打钩，这6个checkbox不打完钩，就不会进入正常的审查流程，最后一个checkbox是审查者在审查完了之后打钩，表示这个pull request没问题，可以进行合并。如果团队的代码审查和代码合并不是同一个人，那么负责合并的人可以在pull request列表里看到每个pull request的进度，如下图<br><img src="pull_request_item.png" alt="pull request item"><br>如果所有checkbox已经完成，表示这个pull request可以进行合并</p><h4 id="通知工具"><a href="#通知工具" class="headerlink" title="通知工具"></a>通知工具</h4><p>用了github，当然是用github强大的邮件通知功能了。为了防止常用邮箱的通知爆炸，可以专门注册一个邮箱来接收github的邮件通知。推荐使用网易邮箱客户端，它有邮件分类功能，可以做到只通知部分邮件，防止打扰。</p><h2 id="代码审查的一些心得"><a href="#代码审查的一些心得" class="headerlink" title="代码审查的一些心得"></a>代码审查的一些心得</h2><ol><li>作为审查者，你需要知道你在给谁review代码</li><li>每个pull request应该尽可能的小，这样才能快速且安全的review</li><li>开放心态，虚心接受别人提的意见，要么采纳，要么说出自己反驳的理由</li><li>我们是人，不是机器，是人就会犯错，很正常</li><li>对公共文件的修改需要加倍关注，这些代码一旦出问题，会导致严重的错误</li></ol><h2 id="附上我们团队代码审查的流程图"><a href="#附上我们团队代码审查的流程图" class="headerlink" title="附上我们团队代码审查的流程图"></a>附上我们团队代码审查的流程图</h2><p><img src="flow.svg" alt="流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="code review" scheme="https://nodepie.com/tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>前端技术之eslint初夜</title>
    <link href="https://nodepie.com/2015/11/03/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8Beslint%E5%88%9D%E5%A4%9C/"/>
    <id>https://nodepie.com/2015/11/03/前端技术之eslint初夜/</id>
    <published>2015-11-03T07:49:26.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置ESLint"><a href="#配置ESLint" class="headerlink" title="配置ESLint:"></a>配置ESLint:</h3><ol><li><strong>Configuration Comments</strong> - use JavaScript comments to embed configuration information directly into a file</li><li><strong>Configuration Files</strong></li></ol><h3 id="几个可配置的参数"><a href="#几个可配置的参数" class="headerlink" title="几个可配置的参数"></a>几个可配置的参数</h3><ul><li><strong>Environments</strong> - 代码运行的环境,不同环境都有不同的默认配置。</li><li><strong>Globals</strong> - 在执行的时候需要的一些全局变量。</li><li><strong>Rules</strong> - 启用哪些规则，错误级别是什么。</li></ul><h3 id="定义js语言特性-ES5-ES6"><a href="#定义js语言特性-ES5-ES6" class="headerlink" title="定义js语言特性(ES5/ES6)"></a>定义js语言特性(ES5/ES6)</h3><blockquote><p>在<code>ecmaFeatures</code>属性里，定义相应的js特性</p></blockquote><ul><li>arrowFunctions - 箭头函数</li><li>binaryLiterals - enable binary literals</li><li>blockBindings - enable let and const (aka block bindings)</li><li>classes - enable classes</li><li>defaultParams - enable default function parameters</li><li>destructuring - enable destructuring</li><li>forOf - enable for-of loops</li><li>generators - enable generators</li><li>modules - enable modules and global strict mode</li><li>objectLiteralComputedProperties - enable computed object literal property names</li><li>objectLiteralDuplicateProperties - enable duplicate object literal properties in strict mode</li><li>objectLiteralShorthandMethods - enable object literal shorthand methods</li><li>objectLiteralShorthandProperties - enable object literal shorthand properties</li><li>octalLiterals - enable octal literals</li><li>regexUFlag - enable the regular expression u flag</li><li>regexYFlag - enable the regular expression y flag</li><li>restParams - enable the rest parameters</li><li>spread - enable the spread operator for arrays</li><li>superInFunctions - enable super references inside of functions</li><li>templateStrings - enable template strings</li><li>unicodeCodePointEscapes - enable code point escapes</li><li>globalReturn - allow return statements in the global scope</li><li>jsx - JSX</li><li>experimentalObjectRestSpread - enable support for the experimental object rest/spread properties (IMPORTANT: This is an experimental feature that may change significantly in the future. It’s recommended that you do not write rules relying on this functionality unless you are willing to incur maintenance cost when it changes.)</li></ul><p>示例代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ecmaFeatures"</span>: &#123;</span><br><span class="line">        <span class="attr">"blockBindings"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"forOf"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Specifying-Parser"><a href="#Specifying-Parser" class="headerlink" title="Specifying Parser"></a>Specifying Parser</h3>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;配置ESLint&quot;&gt;&lt;a href=&quot;#配置ESLint&quot; class=&quot;headerlink&quot; title=&quot;配置ESLint:&quot;&gt;&lt;/a&gt;配置ESLint:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Configuration
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术之怎么在chrome里批量下载base64图片</title>
    <link href="https://nodepie.com/2015/10/13/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%80%8E%E4%B9%88%E5%9C%A8chrome%E9%87%8C%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbase64%E5%9B%BE%E7%89%87/"/>
    <id>https://nodepie.com/2015/10/13/前端技术之怎么在chrome里批量下载base64图片/</id>
    <published>2015-10-13T12:10:41.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>新任务，在chrome里批量下载base64编码的图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes=<span class="built_in">window</span>.atob(base64Str.split(<span class="string">","</span>)[<span class="number">1</span>]);<span class="comment">//base64Str是base64编码的字符串</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length);</span><br><span class="line"><span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] = bytes.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Blob( [ab] , &#123;<span class="attr">type</span> : <span class="string">'image/png'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> url = url = URL.createObjectURL(image);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);<span class="comment">//这里建一个a标签，用于下面下载图片</span></span><br><span class="line">a.href = url;</span><br><span class="line">a.download = fileName;<span class="comment">//fileName是下载的图片名称</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">e.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">a.dispatchEvent(e);<span class="comment">//触发点击事件，开始下载</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;新任务，在chrome里批量下载base64编码的图片。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于ionic在ios9中出现的问题</title>
    <link href="https://nodepie.com/2015/10/13/%E5%85%B3%E4%BA%8Eionic%E5%9C%A8ios9%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/13/关于ionic在ios9中出现的问题/</id>
    <published>2015-10-13T12:02:36.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>[$rootScope:infdig] 10 $digest() iterations reached. Aborting!</span><br><span class="line">Watchers fired in the last 5 iterations: []</span><br></pre></td></tr></table></figure><p>该问题会导致页面的路由出问题，导致页面之间的切换出现异常，鬼火了很久。</p><p>需下载补丁：</p><p><a href="https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js" target="_blank" rel="noopener">https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js</a></p><p>在app.js（启动js）中应用模块：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'ngIOS9UIWebViewPatch</span>'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端的工程问题和技术问题</title>
    <link href="https://nodepie.com/2015/10/06/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E5%92%8C%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/06/前端的工程问题和技术问题/</id>
    <published>2015-10-06T09:23:06.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>做过前端开发一定时间的同学都知道，前端的难点主要集中在两点：工程问题和技术问题。工程问题主要涉及到一系列自动化的问题，比如自动化测试，自动化集成，自动化部署等等；技术问题主要针对前端具体的开发问题了，比如浏览器兼容，页面性能，按需加载等等。</p><p>博主到现在对这些问题也只是了解个皮毛，还需要在接下来的日子和各位同学们一起深入研究探讨。</p><p>之后关于工程方面的问题，都会以<code>前端工程之***</code>为题展开，而关于技术方面的问题，则会以<code>前端技术之***</code>为题展开。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql地理空间使用</title>
    <link href="https://nodepie.com/2015/08/06/mysql%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/08/06/mysql地理空间使用/</id>
    <published>2015-08-06T03:17:49.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat</p><h3 id="创建地理空间数据表"><a href="#创建地理空间数据表" class="headerlink" title="创建地理空间数据表"></a>创建地理空间数据表</h3><p>要使用空间索引，表的类型要选择成MyISAM,貌似表的默认类型就是这个，但是有时候还是需要手动去改。如图</p><p><img src="navicat-1.png" alt="数据表"></p><h3 id="创建地理空间字段"><a href="#创建地理空间字段" class="headerlink" title="创建地理空间字段"></a>创建地理空间字段</h3><p>在我使用的navicat版本里面，创建字段的时候，type一栏里并没有关于地理空间的类型，需要手动输入.常用的类型有：</p><ul><li>GEOMETRY</li><li>POINT</li><li>LINESTRING</li><li>POLYGON</li><li>MULTIPOINT</li><li>MULTILINESTRING</li><li>MULTIPOLYGON</li><li>MULTIPOLYGON</li></ul><h3 id="连接数据库需要注意"><a href="#连接数据库需要注意" class="headerlink" title="连接数据库需要注意"></a>连接数据库需要注意</h3><p>使用以下方式连接.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.31.202 -u root -p -D learndrive <span class="comment">#learndrive是数据库的名称</span></span><br></pre></td></tr></table></figure><h3 id="创建地理空间索引"><a href="#创建地理空间索引" class="headerlink" title="创建地理空间索引"></a>创建地理空间索引</h3><p>在navicat里面无法直接创建SPATIAL索引，需要到shell里用命令行创建.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SPATIAL INDEX sp_index ON site (location); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>连接上mysql之后，直接用上面的代码创建索引，很可能会报错（是对已有的表创建索引造成）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1416 (22003): Cannot get geometry object from data you send to the GEOMETRY field</span><br></pre></td></tr></table></figure><p>先把地理空间字段的值对边填一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `site` SET `location` = POINT( 0,0 ); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>然后再创建索引.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat&lt;/p&gt;
&lt;h3
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.gitlab-ci.yml使用</title>
    <link href="https://nodepie.com/2015/07/09/gitlab-ci-yml%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/07/09/gitlab-ci-yml使用/</id>
    <published>2015-07-09T02:48:50.000Z</published>
    <updated>2018-05-29T12:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>gitlab-ci</code>确实有点坑，为了使用它的runner自动执行<code>shell</code>，然后编译，折腾了一两天，最后发现，呵呵，问题就这样稀里糊涂被解决了.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在工程的根目录添加了<code>.gitlab-ci.yml</code>文件之后,gitlab-ci build的状态每次都是pending，各种搜google，各种stackoverflow，都找不到解决办法。</p><h3 id="gitlab-ci-yml文件内容"><a href="#gitlab-ci-yml文件内容" class="headerlink" title=".gitlab-ci.yml文件内容"></a>.gitlab-ci.yml文件内容</h3><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>最后实在没办法，把之前的runner删了，重新建了一个runner，在提示需要哪个通道的时候，选择shell。</p><h3 id="新建runner的脚本"><a href="#新建runner的脚本" class="headerlink" title="新建runner的脚本"></a>新建runner的脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~gitlab_ci_multi_runner</span><br><span class="line">gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. http://gitlab-ci.org:3000/ )</span><br><span class="line">https://ci.gitlab.org/</span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx</span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">docker</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">ruby:2.1</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but <span class="keyword">if</span> it<span class="string">'s running already the config should be automatically reloaded!</span></span><br></pre></td></tr></table></figure><h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2><p><img src="gitlab-ci.png" alt="Resize icon"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="gitlab,gitlab-ci" scheme="https://nodepie.com/tags/gitlab-gitlab-ci/"/>
    
  </entry>
  
</feed>
