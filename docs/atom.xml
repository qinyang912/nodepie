<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nodepie</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nodepie.com/"/>
  <updated>2021-11-16T02:45:57.000Z</updated>
  <id>https://nodepie.com/</id>
  
  <author>
    <name>Qin Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>polyrepo -&gt; monorepo</title>
    <link href="https://nodepie.com/2021/11/16/polyrepo-monorepo/"/>
    <id>https://nodepie.com/2021/11/16/polyrepo-monorepo/</id>
    <published>2021-11-16T02:38:17.000Z</published>
    <updated>2021-11-16T02:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。</p><p>日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项目的发展，现在微应用的数量已经突破了30个，而polyrepo模式给代码管理带来了巨大的麻烦，尤其是每次要统一升级基础构建的时候，得挨个在每个微应用里执行同样的命令，想想同样的工作要重复几十遍，简直就是噩梦。所以如何更高效的管理微应用成了当前需要解决的一个痛点。在了解了vue,、babel等大型开源项目的解决方案之后，发现monorepo已经在社区有了比较广泛的应用。前端生态里的工具，比如eslint,、babel等也支持monorepo项目的配置，随着<a href="mailto:npm@7.0" target="_blank" rel="noopener">npm@7.0</a>的发布，workspace也成了npm的官方支持，所以现在做monorepo的改造也成了比较水到渠成的事情。</p><h1 id="monorepo-vs-polyrepo"><a href="#monorepo-vs-polyrepo" class="headerlink" title="monorepo vs polyrepo"></a>monorepo vs polyrepo</h1><h2 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h2><p><img src="polyrepo-vs-monorepo.png" alt="img"></p><p>从这张架构图可以看出polyrepo和monorepo最大的区别:</p><p>polyrepo是一个项目一个仓库，且每个项目都有独立的构建工具</p><p>monorepo是多个项目都在同一个仓库，且每个项目共享同一套构建工具</p><h2 id="polyrepo的缺陷"><a href="#polyrepo的缺陷" class="headerlink" title="polyrepo的缺陷"></a>polyrepo的缺陷</h2><p>polyrepo如前文所说，把每个项目都分散到不同的仓库，当项目的数据急剧增加之后，会给整个团队的代码管理带来巨大的负担.</p><h3 id="代码无法方便的同步更新"><a href="#代码无法方便的同步更新" class="headerlink" title="代码无法方便的同步更新"></a>代码无法方便的同步更新</h3><p>构建方案的更新往往是需要所有项目同步更新的，或者某些package.json里的依赖包也是需要同步更新，而这些基础代码都是分散在各个项目的仓库里，为了保持所有项目的统一更新，我们只能一个一个的npm install, 或者一个一个仓库的改代码，然后提交到线上，触发ci/cd，这一套组合拳打下来估计一天时间就过去了</p><h3 id="多项目更新麻烦"><a href="#多项目更新麻烦" class="headerlink" title="多项目更新麻烦"></a>多项目更新麻烦</h3><p>有的需求涉及到同时修改多个项目，在开发的时候，不得不在每个项目单独开分支，单独提交合并，单独触发ci/cd，非常麻烦，而且有的时候修改的项目过多，还容易忘记更新某些项目的代码.</p><h3 id="项目之间的引用不方便"><a href="#项目之间的引用不方便" class="headerlink" title="项目之间的引用不方便"></a>项目之间的引用不方便</h3><p>如果项目相互有依赖，只能各种npm link关联起来，然后进行调试. 有时候如果依赖关系变得复杂, npm link也会变得特别麻烦.</p><p>比如有这么个依赖关系:</p><p>项目A -&gt; 项目B -&gt; 项目C</p><p>这时候为了正常调试，有可能你得做这些npm link：</p><ol><li>在项目A里npm link 项目B，npm link 项目C</li><li>在项目B里npm link 项目C</li></ol><p>这么做太麻烦了，而且有的时候很容易把线上的包和本地npm link的包搞混</p><h2 id="monorepo的优点"><a href="#monorepo的优点" class="headerlink" title="monorepo的优点"></a>monorepo的优点</h2><p>monorepo可以很好的规避上面提到的polyrepo的缺陷</p><p>由于所有代码都在一个仓库里，要同步基础构建和基础代码变得非常容易，当涉及到修改多个项目的时候，也不用再分开提交代码了</p><p>借助npm workspace自带的特性，可以自动的把依赖的项目给link到node_modules下面，从而可以减少npm link的使用</p><p>除了解决polyrepo里提到的缺陷，monorepo还有其他优点.</p><h3 id="所有项目代码一目了然"><a href="#所有项目代码一目了然" class="headerlink" title="所有项目代码一目了然"></a>所有项目代码一目了然</h3><p>所有项目整合到一个仓库之后，后续对仓库的修改和更新都会更加聚合，每个人都能非常方便的看到每个项目的代码的变更情况，更有利于大家的协作。</p><p>且每个人的本地克隆都能非常方便的保持每个项目的最新代码，更容易避免由于某些项目的代码延后带来的bug。</p><h3 id="代码风格更加统一"><a href="#代码风格更加统一" class="headerlink" title="代码风格更加统一"></a>代码风格更加统一</h3><p>当所有项目都在一个仓库之后，所有项目都能共享同一份eslint配置，指定的commit lint规则也能共享，这样就可以保证所有项目的代码都是符合统一的eslint规范，commit message也是符合规范的</p><h2 id="没有100-的合适"><a href="#没有100-的合适" class="headerlink" title="没有100%的合适"></a>没有100%的合适</h2><p>对比了polyrepo的缺点和monorepo的优点之后，你会发现好像polyrepo完全不如monorepo，但俗话说得好，没有万能银弹，合适的才是最好的，polyrepo也有他适合的场景.</p><ol><li>当项目不是很多的时候</li><li>当项目采用的技术方案和构建方案不是特别相似的时候.</li><li>当每个项目的更新都需要及其灵活的时候</li></ol><p>以上三种情况还是用polyrepo比较合适，monorepo会极大的限制灵活性</p><h1 id="monorepo落地"><a href="#monorepo落地" class="headerlink" title="monorepo落地"></a>monorepo落地</h1><p>在npm还不支持workspace之前，管理monorepo的方案基础主要有这些:</p><ol><li>lerna <a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">https://github.com/lerna/lerna</a></li><li>Yarn workspace <a href="https://yarnpkg.com/features/workspaces" target="_blank" rel="noopener">https://yarnpkg.com/features/workspaces</a></li><li>Pnpm workspace <a href="https://pnpm.io/workspaces" target="_blank" rel="noopener">https://pnpm.io/workspaces</a></li></ol><p>lerna是一个第三方的解决方案，他不依赖任何的包管理工具，提供monorepo常用的命令，但是lerna在发布了4.0.0之后，就基本处于无人维护的状态(相关<a href="https://github.com/lerna/lerna/issues/2703" target="_blank" rel="noopener">issue</a>)，PR和issue都没人处理，可能和包管理工具原生对monorepo做支持有关系吧.</p><p>yarn和pnpm的workspace没有仔细研究过，可以自行查看</p><p>在<a href="mailto:npm@7.0.0" target="_blank" rel="noopener">npm@7.0.0</a>发布之后（最近已经更新到<a href="mailto:npm@8.1.3" target="_blank" rel="noopener">npm@8.1.3</a>），npm也支持了workspace，但由于npm的workspace还处在比较早期的阶段，部分monorepo需要的特性都还不支持. 所以我们最终采用的方案是<a href="mailto:npm@8.x" target="_blank" rel="noopener">npm@8.x</a>和lerna配合的方案:</p><p>npm负责做monorepo的最基础管理，比如依赖安装处理，自动link等</p><p>lerna负责monorepo的一些常用功能，比如对比有哪些项目发生了变更，自动更新version，自动生成changelog等</p><p>以下内容会涉及到npm workspace的使用，如果不熟悉，可以提前了解: <a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces/" target="_blank" rel="noopener">https://docs.npmjs.com/cli/v7/using-npm/workspaces/</a></p><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>搭建一个monorepo项目，主要考虑两个环境的问题: 开发环境、构建环境。</p><p>开发环境需要考虑的问题：</p><ol><li>IDE(VS Code)如何更好的辅助开发</li><li>开发工具如何只在monorepo项目的根目录下配置，微应用都能从根目录共享</li><li>提高开发效率</li></ol><p>构建环境需要考虑的问题：</p><ol><li>如何只对变更的代码做lint检查，提高lint速度</li><li>如何只对变更的项目做构建和发布，提高发布速度</li></ol><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><h4 id="各个微应用共享babel配置"><a href="#各个微应用共享babel配置" class="headerlink" title="各个微应用共享babel配置"></a>各个微应用共享babel配置</h4><p>eslint的配置是支持覆盖的, 假设有如下目录结构:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── monorepoRoot</span><br><span class="line">│   ├── packages</span><br><span class="line">│       ├── project-a</span><br><span class="line">│           ├── <span class="selector-class">.eslintrc</span>.js</span><br><span class="line">│       ├── project-b</span><br><span class="line">│           ├── <span class="selector-class">.eslintrc</span>.js</span><br><span class="line">│   ├── <span class="selector-class">.eslintrc</span>.js</span><br><span class="line">│   ├── babel<span class="selector-class">.config</span>.js</span><br><span class="line">│   ├── package.json</span><br></pre></td></tr></table></figure><p>写在monorepoRoot/.eslintrc.js里的eslint配置，都会被project-a/.eslintrc.js和project-b/.eslintrc.js继承。但如果eslint需要使用@babel/eslint-parser作为parser的话就会出现一点小问题，在不做处理的情况下，如果在monorepoRoot下执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run lint -w project-a</span><br></pre></td></tr></table></figure><p>@babel/eslint-parser会报找不到babel配置的问题，@babel/eslint-parser官方已经提供了解决方案:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: <span class="string">"@babel/eslint-parser"</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    babelOptions: &#123;</span><br><span class="line">      rootMode: <span class="string">"upward"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在各个微应用里的.eslintrc.js配置，把parserOptions.babelOptions.rootMode配置为upward即可，这样只要在monorepoRoot下面有babel的配置即可，不用每个微应用添加babel的配置文件. 对应到这个目录结构，只要在project-a和project-b项目下的.eslintrc.js里添加上这个配置即可</p><p>参考: <a href="https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser#additional-parser-configuration" target="_blank" rel="noopener">https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser#additional-parser-configuration</a></p><h4 id="适配vue项目"><a href="#适配vue项目" class="headerlink" title="适配vue项目"></a>适配vue项目</h4><p>如果你的微应用是vue-cli初始化的项目，你会发现所有通过alias引入的代码在vs code的eslint都会报</p><p>Unable to resolve的错误:</p><p><img src="webpack-alias-eslint.png" alt="webpack-alias-eslint"></p><p>这是因为<a href="https://github.com/vuejs/eslint-config-airbnb" target="_blank" rel="noopener">@vue/eslint-config-airbnb</a>里有内置eslint-import-resolver-webpack插件，但这个插件的config参数配置为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'@vue/cli-service/webpack.config.js'</span>)</span><br></pre></td></tr></table></figure><p>参考链接: <a href="https://github.com/vuejs/eslint-config-airbnb/blob/cfa98d5f95be585d72e092f783178518cf3c0aa5/index.js#L10" target="_blank" rel="noopener">https://github.com/vuejs/eslint-config-airbnb/blob/cfa98d5f95be585d72e092f783178518cf3c0aa5/index.js#L10</a></p><p>在普通的vue-cli生成的项目没有问题，上面这行代码没有问题，能通过项目下的vue.config.js解析出webpack配置，然后eslint就能正常解析webpack的alias配置.</p><p>但在monorepo会有问题, 我们来看看@vue/cli-service/webpack.config.js里的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> service = process.VUE_CLI_SERVICE</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!service || process.env.VUE_CLI_API_MODE) &#123;</span><br><span class="line">  <span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'./lib/Service'</span>)</span><br><span class="line">  service = <span class="keyword">new</span> Service(process.env.VUE_CLI_CONTEXT || process.cwd())</span><br><span class="line">  service.init(process.env.VUE_CLI_MODE || process.env.NODE_ENV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = service.resolveWebpackConfig()</span><br></pre></td></tr></table></figure><p>可以看到，如果没有指定process.env.VUE_CLI_CONTEXT环境变量, 会默认从process.cwd()指定文件夹去找到vue.config.js文件，然后解析出对应的webpack配置，在monorepo场景下, 这个process.cwd()取得的值是monorepo的根目录，不是微应用所在的路径，所以我们需要对每个微应用的.eslintrc.js配置做一些调整:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  settings: &#123;</span><br><span class="line">    <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">      [<span class="built_in">require</span>.resolve(<span class="string">'eslint-import-resolver-webpack'</span>)]: &#123;</span><br><span class="line">        config: <span class="built_in">require</span>.resolve(<span class="string">'./eslint.webpack.config.js'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的eslint.webpack.config.js的代码为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'@vue/cli-service/lib/Service'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = <span class="keyword">new</span> Service(path.resolve(__dirname))</span><br><span class="line">service.init(process.env.NODE_ENV)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = service.resolveWebpackConfig()</span><br></pre></td></tr></table></figure><p>这样就能让eslint-import-resolver-webpack从微应用所在的根目录去解析webpack的配置了</p><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><h4 id="babel的配置共享"><a href="#babel的配置共享" class="headerlink" title="babel的配置共享"></a>babel的配置共享</h4><p>babel的配置也是可以实现只在monorepo的根目录维护一份配置文件，不用每个微应用都单独写同样的配置</p><p>官方文档: <a href="https://babeljs.io/docs/en/config-files#monorepos" target="_blank" rel="noopener">https://babeljs.io/docs/en/config-files#monorepos</a></p><p>可以配置rootMode参数为upward，即可告诉微应用在运行babel的时候，配置文件可以到monorepo的根目录寻找</p><p>但是需要注意，rootMode参数是一个Only allowed in Babel’s programmatic options的参数, 也就是只允许在编程环境的配置项使用，比如webpack的babel-loader里使用，不能直接在babel.config.js里使用</p><p>参考: <a href="https://babeljs.io/docs/en/options#rootmode" target="_blank" rel="noopener">https://babeljs.io/docs/en/options#rootmode</a></p><h3 id="vetur"><a href="#vetur" class="headerlink" title="vetur"></a>vetur</h3><p>vetur插件也对monorepo做了额外的支持. 在常规情况下, 我们是不需要在项目的根目录维护一个vetur.config.js文件的，在vs code安装了vetur插件之后，利用默认的配置即可获得足够的开发体验.</p><p>在使用monorepo之后就发现了一个问题:</p><p><img src="vetur-hover-1.png" alt="vetur-hover-1"></p><p>hover到一个引入的方法上面，无法提示这个方法的定义信息，尽管微应用里已经配置了jsconfig.json</p><p>这是因为vetur无法识别到这个微应用里的jsconfig.json文件，需要到monorepo下面的vetur.config.js里配置一个projects参数，告诉vetur，你的微应用在哪些文件夹下面:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  projects: [</span><br><span class="line">    <span class="string">'./packages/project-a'</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="vetur-hover-2.png" alt="vetur-hover-2"></p><p>这样再hover到引入的方法上面就可以正常显示了，按住cmd或者ctrl再点击，也可以跳转到对应的地方去</p><p>参考: <a href="https://vuejs.github.io/vetur/guide/setup.html#advanced" target="_blank" rel="noopener">https://vuejs.github.io/vetur/guide/setup.html#advanced</a></p><h3 id="按需构建和按需lint"><a href="#按需构建和按需lint" class="headerlink" title="按需构建和按需lint"></a>按需构建和按需lint</h3><p>使用monorepo的模式，有一个比较大的问题就是所有项目都在一个仓库，在线上构建或者做lint检查的时候，如果只对一个项目做了修改，结果却要触发所有项目的构建和检查，这将是非常耗时的。所以需要辨别出来到底修改了哪些项目，只对改动的项目做构建和检查.</p><p>这也是我们要引入lerna的原因，npm workspace目前还不支持这些，估计将来也不会支持。</p><p>结合lerna的filter参数，比如scope, since等等，可以非常方便的检测出有哪些项目发生了变化，然后对应着只在这些变动的项目里执行对应的构建和lint命令，节省时间.</p><p>参考lerna的filter: <a href="https://github.com/lerna/lerna/tree/main/core/filter-options" target="_blank" rel="noopener">https://github.com/lerna/lerna/tree/main/core/filter-options</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>monorepo把分散的大型的微应用项目给整合了起来，如果项目之间有非常多的共性，在维护和开发上会得到非常多的便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;所谓monorepo就是同一个仓库管理多个项目的代码，所谓polyrepo就是多个项目的代码分散在多个仓库。&lt;/p&gt;
&lt;p&gt;日事清从19年底开始做微应用拆分到现在整整2年时间，这期间针对微应用打包构建做了很多优化，引入systemjs，抽离公共依赖，统一构建环境等等。随着项
        
      
    
    </summary>
    
    
      <category term="工程化" scheme="https://nodepie.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="monorepo" scheme="https://nodepie.com/tags/monorepo/"/>
    
  </entry>
  
  <entry>
    <title>AST</title>
    <link href="https://nodepie.com/2021/04/06/AST/"/>
    <id>https://nodepie.com/2021/04/06/AST/</id>
    <published>2021-04-06T04:10:30.000Z</published>
    <updated>2021-04-08T10:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align: center;">理解了AST, 就理解了整个前端工具链路</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AST(Abstract Syntax Tree), 抽象语法树, 是源代码的抽象语法结构的树状表现形式.</p><p>抽象语法树是语言无关的, 任何语言都有抽象语法树.</p><p>AST在前端无处不在, 我们熟悉的开发工具几乎全依赖于AST进行开发, webpack, babel, eslint, prettier, istanbul无一不在深度使用AST, 所以学会AST, 你就可以撬动整个工具圈.</p><h2 id="编译器的工作流程"><a href="#编译器的工作流程" class="headerlink" title="编译器的工作流程"></a>编译器的工作流程</h2><p>编译器是AST典型的应用场景, 其最基础的部分就是对AST的处理, 从广义上讲, babel, eslint都属于编译器, 所以我们从分析一个编译器的工作流开始, 来建立对AST的基本认识.</p><p><img src="ast-flow.png" alt="img"></p><p>编译器的工作主要分3个步骤:</p><ol><li>词法分析</li><li>语法分析</li><li>代码生成</li></ol><p>源代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析也叫令牌化(Tokenization), 是在源代码的基础上进行分词断句, 然后生成一连串令牌, 所谓令牌(Token), 其实就是分词断句之后, 对每个单词进行分类, 是属于关键字还是标识符还是标点符号等等. 你可以想象成词法分析就是把你的代码从string类型转换成了数组, 数组的元素就是代码里的单词, 然后对每个单词标记了类型.</p><p>大部分编辑器的语法高亮，就是用的词法分析结果.</p><p>但是词法分析结果缺少一些比较关键的信息:</p><ol><li>没有任何语法信息</li><li>体现不了代码的执行先顺序</li></ol><p>所以需要进一步进行语法分析.</p><figure class="highlight json"><figcaption><span>词法分析结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">"type"</span>: <span class="string">"Keyword"</span>, <span class="attr">"value"</span>: <span class="string">"const"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">"type"</span>: <span class="string">"Identifier"</span>, <span class="attr">"value"</span>: <span class="string">"age"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">"type"</span>: <span class="string">"Punctuator"</span>, <span class="attr">"value"</span>: <span class="string">"="</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">"type"</span>: <span class="string">"Numeric"</span>, <span class="attr">"value"</span>: <span class="string">"18"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">"type"</span>: <span class="string">"Punctuator"</span>, <span class="attr">"value"</span>: <span class="string">";"</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析也叫解析(Parsing), 是在词法分析的基础上, 把令牌列表转换成抽象语法树.</p><p>从下面 <a href="https://astexplorer.net/" target="_blank" rel="noopener">AST Explorer</a> (<a href="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/da825e63460326ff79bbb605085a76901239a012" target="_blank" rel="noopener">在新窗口打开</a>)的数据可以看到, 抽象语法树携带了更多的语法信息, 在词法分析的结果里, 我们只能看到代码里有哪些关键字, 有哪些标识符, 但是在抽象语法树里, 我们却能看出这句代码是在做变量声明.</p><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/da825e63460326ff79bbb605085a76901239a012" width="100%" height="400px" frameborder="0" allowfullscreen></iframe><p>抽象语法树会略去一些无关紧要的信息, 比如代码末尾的<code>;</code>在抽象语法树里没有任何记录, 这也是抽象语法树名字里抽象两个字的由来, 是因为这里的语法并不会表示出真实语法中出现的每个细节.</p><p>联系前面一个步骤, 你可以把这两个步骤想象成DOM树的解析过程, 词法分析就相当于是把HTML代码转换成body, div等各种标签的组合, 而语法分析就相当于是在把各种标签转换成DOM树.</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>有了抽象语法树, 我们可以把代码转换成任何我们想转换成的格式. 就比如我们常用的Babel, 就是把我们写的ES6, ES7语法转换成低版本浏览器可以识别的ES5. </p><p>比如下面这个<a href="https://astexplorer.net/" target="_blank" rel="noopener">AST Explorer</a>例子(<a href="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f3d8a86ef373dc666a77e702de1ce252ad4296fa" target="_blank" rel="noopener">在新窗口打开</a>), 就是利用babel插件, 把<code>const</code>转换成<code>var</code><br><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f3d8a86ef373dc666a77e702de1ce252ad4296fa" width="100%" height="600px" frameborder="0" allowfullscreen></iframe></p><p>为什么非要基于抽象语法树做代码转换, 而不能直接用词法分析结果的令牌列表或者干脆直接读取源代码做字符串替换呢? 原因非常简单, 字符串或者令牌列表没有任何语法信息, 我们很难做到正确转换. 比如, 我们要重命名一个变量, 在令牌列表或者字符串里, 我们很难判断出这个变量的作用域, 以及它还在哪些地方有使用, 以及重命名之后是否会和其他变量名产生冲突, 但如果基于AST做这些, 将会变得异常容易.</p><h2 id="如何阅读AST的数据结构"><a href="#如何阅读AST的数据结构" class="headerlink" title="如何阅读AST的数据结构"></a>如何阅读AST的数据结构</h2><p>JS的AST工具可谓是争奇斗艳, 各家都有各自的实现, 从AST Explorer上可以看到, 有关JS的AST转换工具都有十几个, 但有个好消息是, JS的AST有一个行业标准: <a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree</a>, ESTree定义了每个语法信息在AST里的数据结构, 各家也不是完全按照ESTree定义的结构来实现的AST, 都有增删数据, 但大体上是相同的.</p><p>ESTree里按照每个JS版本的语法规范分别定义了数据结构, 以<code>es5</code>为基础, 后续的<code>es2015</code>, <code>es2016</code>等等都是基于<code>es5</code>进行扩展</p><p>以<code>VariableDeclaration</code>(变量声明)为例, 在es5里的数据结构是:<br><figure class="highlight js"><figcaption><span>https://github.com/estree/estree/blob/master/es5.md#variabledeclaration</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface VariableDeclaration &lt;: Declaration &#123;</span><br><span class="line">  type: <span class="string">"VariableDeclaration"</span>;</span><br><span class="line">  declarations: [ VariableDeclarator ];</span><br><span class="line">  kind: <span class="string">"var"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在es6里的数据结构是:<br><figure class="highlight js"><figcaption><span>https://github.com/estree/estree/blob/master/es2015.md#variabledeclaration</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extend interface VariableDeclaration &#123;</span><br><span class="line">  kind: <span class="string">"var"</span> | <span class="string">"let"</span> | <span class="string">"const"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见, 在es5的基础上, es6新增了let和const</p><p>以下是一个较为复杂的例子(<a href="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f91d69bf54dea7e39a1fb05341f6c261293e05a4" target="_blank" rel="noopener">在新窗口打开</a>):<br><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f91d69bf54dea7e39a1fb05341f6c261293e05a4" width="100%" height="400px" frameborder="0" allowfullscreen></iframe></p><h2 id="babel插件开发入门"><a href="#babel插件开发入门" class="headerlink" title="babel插件开发入门"></a>babel插件开发入门</h2><h3 id="开发手册"><a href="#开发手册" class="headerlink" title="开发手册"></a>开发手册</h3><p>社区里有人写了一份babel的插件手册, 同时也有<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">中文翻译</a>, 非常详尽, 通篇读下来之后, 你会对AST和Babel插件的开发有一个非常全面的认识. 这个手册的最近更新时间是在2017年12月份, 阅读的时候有几个注意点:</p><ol><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-babylon" target="_blank" rel="noopener">babylon</a>: babylon已经非废弃, babel现在用的是<a href="https://github.com/babel/babel/tree/master/packages/babel-parser" target="_blank" rel="noopener">@babel/parser</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#babel-traverse" target="_blank" rel="noopener">babel-traverse</a>: 已经被更新为<a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="noopener">@babel/traverse</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#babel-types" target="_blank" rel="noopener">babel-types</a>: 已经被更新为<a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="noopener">@babel/types</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#babel-generator" target="_blank" rel="noopener">babel-generator</a>: 已经被更新为<a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="noopener">@babel/generator</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#babel-template" target="_blank" rel="noopener">babel-template</a>: 已经被更新为<a href="https://github.com/babel/babel/tree/master/packages/babel-template" target="_blank" rel="noopener">@babel/template</a></li></ol><p>我们前面讲到编译器有三大环节, 这个开发手册主要就是聚焦在第三个环节: 代码生成, 告诉你在babel插件里如何遍历AST, 如何修改AST, 有哪些注意事项. 下面我也按这三个部分, 给大家分析一下.</p><h4 id="如何遍历AST"><a href="#如何遍历AST" class="headerlink" title="如何遍历AST"></a>如何遍历AST</h4><h5 id="深递归遍历"><a href="#深递归遍历" class="headerlink" title="深递归遍历"></a>深递归遍历</h5><p>想要转换AST, 需要对AST树形结构做深递归遍历, 也就是从入口开始, 挨个往下遍历, 遇到一个节点有子节点, 会继续遍历这个节点的子节点，直到把所有的子节点遍历完, 再一步一步返回, 遍历其他节点.</p><p>举例说明:<br><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/04a064de6bde132234c5ee8a83820b83a7e0dd93" width="100%" height="400px" frameborder="0" allowfullscreen></iframe></p><h5 id="Visitors-访问者"><a href="#Visitors-访问者" class="headerlink" title="Visitors(访问者)"></a>Visitors(访问者)</h5><p>访问者模式提供了方法用于在遍历AST的过程中, 获取到具体的节点, 在遍历AST过程中, 会涉及到进入一个节点, 和退出一个节点, 对应的访问者也有这两个模式.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier: &#123;</span><br><span class="line">        enter(path) &#123;&#125;,</span><br><span class="line">        exit(path) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier: &#123;</span><br><span class="line">        enter(path) &#123;&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何修改AST"><a href="#如何修改AST" class="headerlink" title="如何修改AST"></a>如何修改AST</h4><h5 id="Paths-路径"><a href="#Paths-路径" class="headerlink" title="Paths(路径)"></a>Paths(路径)</h5><p>在babel的插件中, 不会让你直接修改对应的节点, babel在AST节点的基础上做了一层封装, 这一层封装叫路径, 一个路径包含有具体的节点, 以及这个节点的父级节点和父级路径, 等其他关联信息. 在访问者函数里的第一个参数就是路径.</p><p>你可以想象成路径是babel暴露给我们的最外层的接口, 我们所有的操作都需要基于路径提供的接口来实现</p><h5 id="Scopes-作用域"><a href="#Scopes-作用域" class="headerlink" title="Scopes(作用域)"></a>Scopes(作用域)</h5><p>每个路径上都有一个<code>scope</code>属性, 用于标明这个路径所属的作用域是哪个.</p><h5 id="Bindings-绑定"><a href="#Bindings-绑定" class="headerlink" title="Bindings(绑定)"></a>Bindings(绑定)</h5><p>每个<code>scope</code>上都有一个<code>bindings</code>属性, 用于标明这个作用域下绑定了多少引用.</p><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p><a href="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f7086c21a276863db5363075a2d53c61e8d67fc2" target="_blank" rel="noopener">新窗口打开</a>, 需要打开控制台查看路径信息</p><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/f7086c21a276863db5363075a2d53c61e8d67fc2" width="100%" height="600px" frameborder="0" allowfullscreen></iframe><h5 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel/parser"></a>@babel/parser</h5><p>是babel把源代码转换成AST的核心部件, 但一般开发插件用不到, 因为我们可以通过访问者模式, 直接拿到路径信息</p><h5 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h5><p>是babel提供的用于递归遍历AST的部件</p><h5 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel/types"></a>@babel/types</h5><p>是babel提供的一个转换AST的工具集，你可以想象成babel的lodash, 里面有很多现成的api可用.</p><p>我们在写插件的时候, 暴露出去的方法会获得一个babel对象, 里面有个属性值<code>types</code>, 就是这个<code>@babel/types</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(babel.types)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel/generator"></a>@babel/generator</h5><p>是babel提供的一个代码生成器, 把转换之后的AST生成对应的代码, 插件里一般用不到</p><h5 id="babel-template"><a href="#babel-template" class="headerlink" title="@babel/template"></a>@babel/template</h5><p>是babel提供的部件, 可以基于字符串模板生成AST</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>babel的插件系统非常庞大, 但是他的开发文档, 确实不怎么友好, 很多接口都需要翻阅源码才能找到. 下面就注明一些接口文档的地址.</p><ul><li>@babel/types: <a href="https://babeljs.io/docs/en/babel-types.html" target="_blank" rel="noopener">https://babeljs.io/docs/en/babel-types.html</a></li><li>babel的AST规范: <a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md" target="_blank" rel="noopener">https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md</a></li><li>路径相关接口:<ul><li><a href="https://github.com/babel/babel/tree/1ef78ca55b39773cbb5974960b7b34e2fca6e043/packages/babel-traverse/src/path" target="_blank" rel="noopener">https://github.com/babel/babel/tree/1ef78ca55b39773cbb5974960b7b34e2fca6e043/packages/babel-traverse/src/path</a></li></ul></li><li>作用域相关接口:<ul><li><a href="https://github.com/babel/babel/tree/1ef78ca55b39773cbb5974960b7b34e2fca6e043/packages/babel-traverse/src/scope" target="_blank" rel="noopener">https://github.com/babel/babel/tree/1ef78ca55b39773cbb5974960b7b34e2fca6e043/packages/babel-traverse/src/scope</a></li></ul></li><li>AST节点类型的定义: <a href="https://github.com/babel/babel/tree/5b99b8f2217eb253edc66728eedb2ec260d8065d/packages/babel-types/src/definitions" target="_blank" rel="noopener">https://github.com/babel/babel/tree/5b99b8f2217eb253edc66728eedb2ec260d8065d/packages/babel-types/src/definitions</a></li></ul><h3 id="babel插件-移除vue的公共接口调用"><a href="#babel插件-移除vue的公共接口调用" class="headerlink" title="babel插件: 移除vue的公共接口调用"></a>babel插件: 移除vue的公共接口调用</h3><p>这个babel插件是日事清的vue-cli-plugin-rishiqing里的一个功能. 日事清的web端是基于微应用进行开发的, 由于各个微应用在线上的时候是共用同一个vue, 为了防止微应用里不小心调用vue的公共接口导致全局的vue的状态被污染, 然后开发了这么一个babel插件, 在构建生产环境的微应用代码的时候自动把这些调用公共接口的代码给移除了.</p><p>公共接口包括:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive</span><br><span class="line">Vue.filter</span><br><span class="line">Vue.component</span><br><span class="line">Vue.use</span><br><span class="line">Vue.mixin</span><br><span class="line">Vue.config</span><br><span class="line">Vue.prototype</span><br></pre></td></tr></table></figure></p><p><a href="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/69c709b0c2f727c34d855233bb7fbd9c111d2313" target="_blank" rel="noopener">在新窗口打开</a><br><iframe src="https://astexplorer.net/#/gist/3fad609ffc39889a0af69602bc57c0b7/69c709b0c2f727c34d855233bb7fbd9c111d2313" width="100%" height="600px" frameborder="0" allowfullscreen></iframe></p><h2 id="AST的其他应用场景"><a href="#AST的其他应用场景" class="headerlink" title="AST的其他应用场景"></a>AST的其他应用场景</h2><h3 id="有人知道istanbul是如何检测代码的测试覆盖率的吗"><a href="#有人知道istanbul是如何检测代码的测试覆盖率的吗" class="headerlink" title="有人知道istanbul是如何检测代码的测试覆盖率的吗?"></a>有人知道istanbul是如何检测代码的测试覆盖率的吗?</h3><h3 id="有人知道为什么eslint要留一个parser参数-供用户配置吗"><a href="#有人知道为什么eslint要留一个parser参数-供用户配置吗" class="headerlink" title="有人知道为什么eslint要留一个parser参数, 供用户配置吗?"></a>有人知道为什么eslint要留一个parser参数, 供用户配置吗?</h3><h3 id="有人想过-如何一键把vue2-0的代码自动重构成vue3-0的代码吗"><a href="#有人想过-如何一键把vue2-0的代码自动重构成vue3-0的代码吗" class="headerlink" title="有人想过, 如何一键把vue2.0的代码自动重构成vue3.0的代码吗?"></a>有人想过, 如何一键把vue2.0的代码自动重构成vue3.0的代码吗?</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.twilio.com/blog/abstract-syntax-trees" target="_blank" rel="noopener">https://www.twilio.com/blog/abstract-syntax-trees</a></li><li><a href="https://www.semantics3.com/blog/understanding-code-coverage-1074e8fccce0/" target="_blank" rel="noopener">https://www.semantics3.com/blog/understanding-code-coverage-1074e8fccce0/</a></li><li><a href="https://eslint.org/docs/developer-guide/working-with-custom-parsers" target="_blank" rel="noopener">https://eslint.org/docs/developer-guide/working-with-custom-parsers</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
&lt;p style=&quot;text-align: center;&quot;&gt;理解了AST, 就理解了整个前端工具链路&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="AST" scheme="https://nodepie.com/tags/AST/"/>
    
      <category term="抽象语法树" scheme="https://nodepie.com/tags/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    
      <category term="babel" scheme="https://nodepie.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>我6年的远程工作</title>
    <link href="https://nodepie.com/2020/03/29/%E6%88%916%E5%B9%B4%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/"/>
    <id>https://nodepie.com/2020/03/29/我6年的远程工作/</id>
    <published>2020-03-29T06:24:22.000Z</published>
    <updated>2020-04-05T09:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想记录一下这6年的远程工作，所以趁这个闲暇的星期天下午，写下了这篇文章。不吹不黑，以客观事实的态度，给大家呈现一个真实的远程工作者的状态。</p><p>可能和大部分的远程工作者都不一样，我几乎是大学毕业，第一份工作就是远程的形式，也就是第一份工作就到了日事清，怎么也没想到，这一远程就坚持了6年，虽然中途也有些插曲，但总的来说，我的工作基本都是远程状态，所以对远程工作这个话题，还是有些话可以说的。</p><h1 id="为什么会远程"><a href="#为什么会远程" class="headerlink" title="为什么会远程"></a>为什么会远程</h1><p>以下内容有点流水账，一句话：</p><blockquote><p>毕业找工作遇阻，机缘巧合，来到了日事清，入职没多久就开始远程工作</p></blockquote><p>我是2014年本科毕业，专业是电子信息工程，虽然专业和计算机沾边，但更多是偏向硬件，底层电路，嵌入式。在大学的4年时间，和室友还有隔壁寝室的同学一起组队，参加了很多电子设计竞赛，他们主要是负责电路的设计，我主要负责计算单元的编程，比如51单片机，stm32，FPGA等，不过那时候基本都是写C和C++以及FPGA专用的Verilog。</p><p>在快大四的时候，和同学给一老师开发一套管理系统，需要软硬件结合。这位同学做硬件部分，我来负责服务器和客户端的开发。当时还比较流行B/S的说法，浏览器 + 服务器的模式。因为这个机会，我开始接触前端，发现前端真的是一个宝藏行业，比嵌入式开发有趣太多，而且不用接触底层硬件（有点讨厌焊锡的味道）。这么看来，我算是从这个项目开始入门前端的吧，也从此决定转前端开发。</p><p>毕业找工作的时候，开始恶补前端知识，但因为自己能力实在太菜，错过了很多大厂的招聘。后来在毕业前几个月，经一学长介绍，去了一家做轮船发动机控制系统的公司实习，做嵌入式开发，和我的专业高度相关。但心里一直没有放下做前端开发的念想。后来实习期还没结束，在缘创派上结识了我们的CEO——石叁，经过CTO简单的面试，在2014年7月份入职了日事清。</p><p>当时日事清在成都还有个简单的办事处，不过那时候公司的业务还不仅仅是日事清，还有外包业务，所以我最开始是没有远程的想法的。入职2个月左右，公司在成都这边的业务结束了，所有的小伙伴会搬回北京，CEO也问我想不想去北京，我当时是一百个不愿意，后来经过商议，决定让我在成都远程办公。我的远程工作，就这么毫无期待的，在2014年9月份开始了，记得那年夏天特别热。</p><h1 id="远程体验"><a href="#远程体验" class="headerlink" title="远程体验"></a>远程体验</h1><h2 id="开始很新鲜"><a href="#开始很新鲜" class="headerlink" title="开始很新鲜"></a>开始很新鲜</h2><p>刚开始远程的时候特别新鲜，想着自己不用每天早起搭地铁，睡到早上8点半，起床洗漱吃个早饭就可以开始工作，真是完美。</p><p>不用打卡，只要完成每天的任务就可以，工作时间特别自由。刚开始一段时间经常是早上起得特别晚，为了完成任务经常会工作到晚上2、3点，然后继续早上起不来，如此恶性循环。</p><p>工作地点也可以特别自由，成都冬天和春天的太阳特别难得，在天气特别好的时候，可以去公园里找个阳光充足的地方，窝在吊床里办公</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/zhiwuyuan.jpg" style="height: 400px"></p><p>父母在昆明，有时候会在周末搭个动车去昆明，然后在昆明工作一段时间再回成都，还可以顺道去洱海边敲几行代码</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/dali.jpeg" style="width: 80%;"></p><p>在家里待烦了，可以去咖啡厅写代码，装逼也好，但偶尔去一次咖啡厅工作效率会非常高，在有点声音的环境下，会更容易专注</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/coffee.jpg" style="width: 80%;"></p><h2 id="逐渐适应"><a href="#逐渐适应" class="headerlink" title="逐渐适应"></a>逐渐适应</h2><p>大概远程3个月之后，最初的新鲜劲开始慢慢消失，逐渐意识到如果还这样没有时间规律的工作下去，身体和心理，迟早都会出问题，遂开始制定一些规范：</p><pre><code>1. 必须早起，不能想着工作可以堆到晚上来做 2. 在规定的时间办公，和去公司上班的同事保持一致 3. 每周必须去3次健身房，必须运动，流汗，分泌多巴胺 4. 每周可以有2到3次外出工作，不能总待在家里工作</code></pre><p>我博客首页上的那句slogan就是这段时间的感悟：自律，才能更自由。自律，不仅仅是表示一个人能按时完成团队分配的任务，更应该克制个人的行为和习惯，看似自律和自由有所违背，但自律，意味着更高效的时间利用，从长远来说，可以让人更自由。</p><h2 id="压抑期"><a href="#压抑期" class="headerlink" title="压抑期"></a>压抑期</h2><p>人毕竟还是群居动物，长时间一个人办公，工作上积累的情绪无法排解，真的会把人压得喘不过气。</p><p>我应该算是一个比较能独处的人了，容易静得下心来，但长期的远程，真的快把我都整抑郁了。</p><p>长时间和同事的沟通只能靠文字，语音，视频，无法面对面沟通，体会不到对方的情绪，每天就自己一个人在家里上班。而且最开始由于条件所限，办公桌就在卧室里，起床就能看到电脑，工作和生活极难分开，非常难受，有一段时间，是真的想放弃远程工作，感觉远程并没有想象的那么好。</p><h2 id="回到正轨"><a href="#回到正轨" class="headerlink" title="回到正轨"></a>回到正轨</h2><p>从2016年开始，每年会有大概2个月时间去北京和同事们集中办。北京的人是真的多，每次上班挤完地铁，还得接着挤办公楼的电梯，有时候电梯实在等不到，还得爬楼梯上去，老难受了。但还是很开心，和同事们在一起工作，面对面交流的感觉是视频永远替代不了的。</p><p>2018年初，搬了家，终于有一个独立办公室了，虽然小，但好歹不用和卧室放在一起，从物理上把办公区和生活区隔离开。买了一个电动升降桌，方便站立办公，预防职业病，再置办了一些办公用品，好好改造了一下办公区。如果正在远程办公的你，也强烈建议好好打造一下办公环境，这点投入是非常值得的。</p><p>2018年底，我们在南京也组建了团队，前端团队变得更大，责任也就更大了，出差的频率也开始增加。我现在在成都，北京，南京三个城市之间，远程和集中办公交替着。</p><h1 id="聊聊远程工作"><a href="#聊聊远程工作" class="headerlink" title="聊聊远程工作"></a>聊聊远程工作</h1><p>随着互联网各种办公软件的崛起，如今想要开展远程工作的基础条件已经完全具备。而能否高效进行远程工作，主要是各种软实力在决定，一个是远程工作者的个人能力，一个是团队的远程协作能力。</p><p>远程工作者的个人能力不多，核心就要求两点：自律 + 工作胜任力。</p><p>自律，也可以叫做自我管理的能力，肯定是远程工作者需要的第一能力，也是最重要的，没有这一项，其他一切免谈。一个人在家办公和一群人在公司上班，对上班的个体来说，有非常大的不同。一群人在公司上班，由于群体在一起形成的监督效应，你是不好意思一会儿看看手机，一会儿刷刷视频的，虽然办公环境会有人为干扰，但总体来说对个人影响不是很大，尤其是程序员，戴上耳机，基本就与世隔绝了。但是在家里，如果没有自制力，你一会儿刷刷抖音，一会儿刷刷知乎，谁也看不到，时间就这样过去了。如果是一个有责任心的程序员，可能会晚上加班把白天没有做完的任务给补上，但是这样会搞得自己特别累，没法长久。</p><p>工作的胜任力，这自不必多说，不管是在远程还是在公司办公，都必须有胜任工作的能力。</p><p>对于一个支持远程办公的公司来说，团队的远程协作能力才是真正的核心。协作流程决定着一个团队能否在远程时也保持高效，另外对于开发团队来说，开发团队所用的工具链，能否高效的支持远程开发，也决定着一个开发团队的投入产出比。</p><p>日事清的大本营一直都在北京，从最初只有我一个人在远程，到现在我们在南京也成立了团队，还有部分同事在辽宁朝阳，长沙，广州远程工作，所以对于我们团队来说，一套高效的远程协作流程是非常重要的。</p><h2 id="开发团队的远程协作"><a href="#开发团队的远程协作" class="headerlink" title="开发团队的远程协作"></a>开发团队的远程协作</h2><p>沟通，消除信息的不对称，估计是大部分远程团队遇到的首要问题。对于我们来说也一样，但日事清就是用来解决这个问题的。</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/development.jpg" style="width: 80%;"></p><p>我们研发组有一个自己的开发计划：「迭代开发」，所有待开发的任务全部放到「规划池」这个卡片，并打上对应的标签，标明任务的优先级，然后分配对应的开发人员，并沟通开发周期，开发人员在开始做的时候，会把任务拖到「开发中」，任务完成之后，开发人员会打钩，然后拖动到「测试中」，并在任务里@对应的测试人员，测试完成之后，会拖动到「待发布」里，等到发布时间，负责发布的同事会新建一个卡片，命名规则为：发布-xxxx-xx-xx，以发布当天的日期作为标记，并把所有发布了的任务拖到这个卡片里，同时再新建一个发布公告任务，在任务里简要写完本次的发布内容，并@全公司的人。</p><p>对于复杂的功能，开发周期一般都比较长，除了在「迭代开发」里建一个任务，还会单独建立一个子计划，用来对需求做拆分和排期，方便进度追踪</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/jianbao.jpg" style="width: 80%;"></p><p>除了「迭代开发」之外，我们还有其他几个和产品以及测试相关的子计划：</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/sub-plan.jpg" style="width: 80%;"></p><p>需求会之前，产品会从「产品需求」里把任务移动到「迭代开发」的「规划池」里，每次需求会，我们所有人只用聚焦在「迭代开发」这个子计划里即可，回顾我们之前的开发任务，以及目前正在开发的任务的情况，以及即将开发的功能。</p><h2 id="远程站会"><a href="#远程站会" class="headerlink" title="远程站会"></a>远程站会</h2><p>为了加强团队成员的沟通，我们会在每天下班之前开30分钟左右的站会，沟通一下大家当天的开发情况，有没有遇到什么问题，以及有什么需要分享的。所有的沟通记录都会保存在日事清的笔记里：</p><p style="text-align: center;"><img src="/2020/03/29/我6年的远程工作/zhanhui.jpg" style="width: 80%;"></p><p>日事清的笔记支持多人实时在线编辑，每次开站会的时候，主持人会新建一篇笔记，并共享屏幕，参与站会的同事可以挨个说自己做了些啥，有什么问题需要讨论，主持人随时记录，如果有需要分享图片或者文件的同事，每个人都可以直接往这篇笔记里上传，主持人那边可以实时显示其他同事上传和编辑的任何内容，提高会议效率。</p><h2 id="远程开发工具"><a href="#远程开发工具" class="headerlink" title="远程开发工具"></a>远程开发工具</h2><h3 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h3><p>我们2018年以及之前都一直在用github的企业版，就是不想浪费时间去维护gitlab的私有部署。但是2018年底，我们开发团队扩大了，同时私有项目也变得更多，考虑到用github的成本，以及国内使用github的网络问题，最终还是决定自己部署gitlab。</p><p>gitlab真的是小型开发团队的福音。我们都知道github的pr做代码审查非常的便捷，在用了gitlab一段时间之后，发现gitlab并不比github弱多少。代码审查一样非常便捷，也可以基于代码进行讨论。</p><p>还有gitlab-ci，自动化做持续集成持续部署，尤其是把gitlab-ci部署到k8s，利用docker的生态，可以非常方便的做各种自动化处理，并不逊色于travis和circle-ci</p><p>gitlab也可以和实时通信工具打通，我们团队的实时沟通工具用的钉钉，钉钉里也有gitlab机器人，但是这个机器人比较弱，能处理的通知类型太少了。基于gitlab的开放接口和钉钉提供的开放接口，我们做了一些自定义通知工具。这样代码仓库里有任何动向，都可以实时发消息到钉钉的群里，提高效率。</p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>之所以要把ngrok单独拎出来说一下，就是因为这个工具在远程办公的时候关键时刻会起到非常大的作用。</p><p>我们有自己的线上开发环境，在大多数情况下，后台和前端需要联调的时候，后端会把代码推到线上开发环境，前端直接连线上开发环境进行调试即可。但有的时候会遇到问题，后台又不好排查，需要让前端直接访问后台的本地环境。大家在一个局域网还好说，但是远程，就必须想其他办法了。</p><p>ngrok就是这么一个工具，它可以方便把本地的开发环境映射到公网去，可通过公网访问本地的服务器。ngrok最早期版本还是开源的，但是ngrok2出来之后就没有开源了。我们在线上用ngrok旧版搭建了一个ngrok服务器，一样好用，感谢开源社区。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>远程工作并不适合每个人，也并不适合每个团队。对于个人来说，你需要有更强大的自我管理能力，自律，要耐得住寂寞。对于团队来说，没有一套比较好的协作流程，远程的效率必然得不到保障。但远程也有他的魅力，可以节省通勤时间，在工作地点的选择上更加自由，工作环境也更加可控，支持远程的团队，可以在全国，甚至全球范围内笼络人才，让组织的生命力更加顽强。尤其是今年初爆发的疫情，对于支持远程办公的团队来说，应对起来肯定会更得心应手。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="远程工作" scheme="https://nodepie.com/tags/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="远程管理" scheme="https://nodepie.com/tags/%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
      <category term="自我管理" scheme="https://nodepie.com/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>微前端实践</title>
    <link href="https://nodepie.com/2020/03/02/%E6%97%A5%E4%BA%8B%E6%B8%85%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/"/>
    <id>https://nodepie.com/2020/03/02/日事清的微前端之路/</id>
    <published>2020-03-02T13:15:37.000Z</published>
    <updated>2020-03-10T05:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>日事清的web端从诞生之初就一直用的backbone进行开发，当时的包管理器还用的require.js，构建方案还是grunt。后来在2016年，我们把构建方案换成了webpack，但是考虑到整个团队的学习成本，也考虑到项目的稳定性，再加上为了快速上线，视图框架还是用的Backbone，这个架构也就一直用到现在。</p><p>我们也鼓励团队成员用vue开发新的项目，在对比backbone和vue的开发效率的时候，我们发现，vue的效率高的不止一点点，且开发体验要比backbone好太多，所以什么时候能把backbone换成vue一直是我们的心愿。但没有业务场景，且现在项目又稳定，我们是绝不可能轻易迈出这一步的。</p><p>机会出现在了2019年10月份，日事清web端准备大版本迭代，新版的设计图和之前的几乎完全不一样，新增了非常多的功能，已有功能也做了非常多的优化。经过讨论，我们决定对项目进行重构，重构就意味着我们有机会引入新技术。</p><p>但是此次重构有点特别，如果用过日事清的小伙伴应该知道，日事清分：日程，计划，笔记，应用，公司5个模块，但日程不参与此次重构，其他几个模块都需要分批进行重构，且最好是重构完一个模块，就上线一个模块。也就是说，如果我们想用vue来重构，必须要backbone和vue共存一段时间，然后再逐步把所有的backbone替换掉。</p><p><img src="rishiqing-module.jpg" alt="rishiqing-module.jpg"></p><p>最终我们决定引入微前端的架构，选择微前端可以非常好的解决这次重构遇到的问题：</p><ol><li>多个技术框架可共存使用，即使用vue不会对已有的backbone造成影响</li><li>可灵活的进行渐进式重构</li><li>进行重构的模块可以选择新的技术方案</li><li>后续重构的模块可独立发布</li></ol><h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><p>目前业界比较成熟的微前端方案主要是两种：iframe和singleSpa</p><p>iframe:</p><p>日事清之前有部分功能就是用iframe的方式嵌套在页面里的，但是这种嵌套的方式有很多限制：</p><ol><li>iframe内部的事件不能冒泡出来，导致很多交互都需要postMessage来对接，非常麻烦</li><li>ifame内部的全局弹窗不能全尺寸弹出，影响用户体验</li></ol><p>singleSpa:</p><p>开源项目<a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>，它的实现思路是：一个主应用和若干个子应用</p><p>​    主应用：负责子应用的注册、挂载和销毁</p><p>​    子应用：提供三个接口：bootstrap, mount, unmount供主应用调用</p><p>我们最终选择了singleSpa，主要原因是：</p><ol><li>子应用可以挂载在主应用的某个元素下面，可以和主应用共享一个执行环境</li><li>子应用的注册、挂载和销毁逻辑相对简单，如果放到脚手架里，所有子项目都可以共用</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="路由管理-amp-子应用注册"><a href="#路由管理-amp-子应用注册" class="headerlink" title="路由管理 &amp; 子应用注册"></a>路由管理 &amp; 子应用注册</h2><p>我们需要管理3部分的路由：</p><ol><li>原有的backbone路由</li><li>singleSpa注册子应用的路由</li><li>子应用内部的路由</li></ol><p>我们原有的backbone的路由的对应关系是这样的：</p><table><thead><tr><th style="text-align:left">模块</th><th>路由</th></tr></thead><tbody><tr><td style="text-align:left">日程</td><td>/app/todo</td></tr><tr><td style="text-align:left">计划</td><td>/app/kanban</td></tr><tr><td style="text-align:left">笔记</td><td>/app/doc</td></tr><tr><td style="text-align:left">应用</td><td>/app/application</td></tr><tr><td style="text-align:left">公司</td><td>/app/company</td></tr></tbody></table><p>这次除了日程模块之外，其他几个模块都会重构，也即其他几个模块的路由都不走backbone。</p><p>singleSpa支持通过路由的方式来判断是否挂载子应用，且引入singleSpa并不会影响backbone的路由的正常工作，所以我们只用把日程之外的其他几个模块的路由从backbone移除，然后把其他几个模块当做子应用注册到singleSpa即可。</p><p>以注册笔记模块为例，下面是注册部分的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> singleSpa <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lifecycleFn = [<span class="string">'bootstrap'</span>, <span class="string">'unmount'</span>, <span class="string">'mount'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTAINER_CACHE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一下子应用暴露的方法，至少保证生命周期函数是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapLifecycle</span> (<span class="params">life = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!life) life = &#123;&#125;;</span><br><span class="line">  lifecycleFn.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!life[method] || <span class="keyword">typeof</span> life[method] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      life[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> life;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span> (<span class="params">containerId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  container.id = containerId;</span><br><span class="line">  <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 应用名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>options 可选配置参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.containerId 元素容器的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.appPath 元素的路径，如果不传则默认为 /app/$&#123;name&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerApplication</span> (<span class="params">name, options</span>) </span>&#123;</span><br><span class="line">  singleSpa.registerApplication(name, loadApp(name), (location) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> appPath = options.appPath || <span class="string">`/app/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> active = location.pathname.startsWith(appPath);</span><br><span class="line">    <span class="keyword">if</span> (active) &#123;</span><br><span class="line">      <span class="comment">// 这里之所以这样做，是因为这个方法可能会被执行多次，为了防止container重复创建</span></span><br><span class="line">      <span class="keyword">if</span> (!CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        <span class="keyword">const</span> container = createContainer(options.containerId);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">        CONTAINER_CACHE[name] = container;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        CONTAINER_CACHE[name].parentElement.removeChild(CONTAINER_CACHE[name]);</span><br><span class="line">      &#125;</span><br><span class="line">      CONTAINER_CACHE[name] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    containerId: options.containerId</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注册笔记</span></span><br><span class="line">  registerApplication(<span class="string">'doc'</span>, &#123;</span><br><span class="line">    containerId: <span class="string">'doc-container'</span></span><br><span class="line">    appPath: <span class="string">'/app/doc'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  singleSpa.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当有路由变化的时候，singleSpa.registerApplication的第三个参数就会执行，然后判断路径是否是<code>/app/doc</code>开头的，如果是，则说明需要挂载笔记这个子应用。</p><p>在判断可以挂载子应用之后，主应用会创建一个Div容器，然后把这个容器传给子应用，子应用在执行挂载逻辑的时候，就会把整个应用都挂载在这个Div里面。</p><p>大家可能有注意到，代码里有用到一个全局变量System，这个是<a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">systemjs</a>暴露出来的，用来加载线上的js模块，后面讲怎么发布的时候会详细讲到。</p><p>在笔记子应用里需要暴露出single-spa挂载和销毁要用到的三个周期函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 启动函数</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-empty-function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  vueContainer = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;props.containerId&#125;</span>`</span>)</span><br><span class="line">  el.appendChild(vueContainer.$el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vueContainer) &#123;</span><br><span class="line">    vueContainer.$destroy()</span><br><span class="line">    <span class="keyword">if</span> (vueContainer.$el.parentElement) &#123;</span><br><span class="line">      vueContainer.$el.parentElement.removeChild(vueContainer.$el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mount的时候初始化子应用的入口vue组件，并挂载到主应用那边传过来的一个div下面</p><p>在unmount的时候，执行$destroy，销毁应用</p><p>上面提到，我们需要管理3部分路由，最后一部分子应用内部的路由，就在这里mount的时候直接初始化了。之后只要在这个子应用里的路由跳转，都能经过vue-router进行处理。</p><h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>数据层是一个非常庞大且复杂的话题，限于篇幅，简单讲一下我们的数据层是怎么设计的.</p><h3 id="打通backbone和vue之间的数据"><a href="#打通backbone和vue之间的数据" class="headerlink" title="打通backbone和vue之间的数据"></a>打通backbone和vue之间的数据</h3><p>在考虑数据层怎么设计的时候，遇到的第一个问题是：我们的主应用是基于backbone开发的，数据管理是backbone提供的collection和model，但是我们的子应用是用vue进行开发，要怎么打通backbone和vue之间的数据进行共享。</p><p>在解决这个问题的时候，我们都有一个共识，首先需要保证原有的backbone的数据稳定，代码能不动的尽量不动，等所有模块都用vue重构完了之后，让backbone自然而然的退役。经过分析之后，我们发现主应用里需要共享的就这么几类数据：</p><ol><li>用户的基础数据</li><li>组织架构数据</li><li>websocket实时推送数据</li></ol><p>用户基础数据和组织架构数据每个子应用都会用到，为了避免子应用再调接口去获取这些数据，需要想办法把这两个数据共享出去</p><p>主应用里有用到websocket来接收实时数据，拆分之后的子应用也需要用到websocket，我们最终决定只在主应用里初始化webscoket连接，不在各子应用再建立webscoket，原因如下：</p><ol><li>需要建立websocket的子应用比较多，如果每个都单独建立，会增加服务器的压力</li><li>子应用会随着路由的变化而挂载或者销毁，会导致频繁的建立websocket</li><li>在主应用和子应用之间嫁接一个事件总线，当主应用收到实时数据之后，就在这个事件总线上触发一个事件，子应用只要挂载之后就订阅这个事件，这样子应用也能及时收到实时数据</li></ol><p>基于上面的考虑，我们设计了一个中间层，代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'eventemitter3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageClient = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础数据</span></span><br><span class="line"><span class="keyword">const</span> BasicData = &#123;</span><br><span class="line">  USER_INFO: &#123;&#125;,</span><br><span class="line">  USER_TREE: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setBasicData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(BasicData, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBasicData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BasicData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息客户端</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getMessageClient</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> messageClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往消息客户端发送消息(ws实时消息)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  messageClient.emit(<span class="string">'message'</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主应用在初始化了之后，调用<code>setBasicData</code>把用户基础数据和组织架构数据放到BasicData里缓存起来，每个子应用初始化之后，只要调用<code>getBasicData</code>，即可获取到基础数据，而不用再调接口</p><p>主应用在收到websocket数据之后，调用<code>sendMessage</code>往事件总线上触发一个<code>message</code>事件，子应用只要通过<code>getMessageClient</code>拿到这个消息客户端，然后订阅<code>message</code>事件，即可收到实时数据，子应用销毁之后，取消订阅即可</p><h3 id="vue内部的数据管理"><a href="#vue内部的数据管理" class="headerlink" title="vue内部的数据管理"></a>vue内部的数据管理</h3><p>子应用里有用到<a href="https://rxdb.info/" target="_blank" rel="noopener">Rxdb</a>做数据管理，这里就不展开了，有机会今后可以另外写一篇</p><h2 id="组件-amp-代码复用"><a href="#组件-amp-代码复用" class="headerlink" title="组件&amp;代码复用"></a>组件&amp;代码复用</h2><p>引入微前端架构之后，面临着一个非常大的问题：所有子应用都被拆分成独立的仓库进行独立维护了，那怎么进行代码和组件的复用?</p><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>好在我们从19年初就有意识的在开发我们内部的组件库，基于业务需要，我们在开发自己的组件库的时候把组件分成了两类：</p><ol><li>基础组件</li><li>业务组件</li></ol><p>基础组件主要包括: button, icon, popover, modal, tree这种通用组件</p><p>业务组件主要包括：成员选择器，日期选择器这种业务强相关的组件</p><p>我们的子应用都是基于我们自己的组件库进行开发的，组件库支持按需引入，尽量减少代码体积</p><h3 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h3><p>vue-cli的脚手架在我们这次重构过程中起到了非常大的作用，它的作用仅次于我们的组件库。</p><p>用过vue-cli的同学应该都知道，vue-cli和普天之下的其他cli一样，支持代码模板，支持preset，也支持自定义插件。为了方便团队成员使用vue，我们在18年就开始开发自己的vue-cli插件，可快速初始化我们内部需要的各种项目。</p><p>使用脚手架的收益会逐年增大，尤其是当团队里需要开发的应用越来越多，收益会越来越大。</p><h4 id="快速初始化项目"><a href="#快速初始化项目" class="headerlink" title="快速初始化项目"></a>快速初始化项目</h4><p>我们把一个微应用需要用到的基础代码全部放到vue-cli插件里的generator里，使用插件，可快速创建一个满足我们自己需求的微应用。</p><h4 id="webpack配置统一管理"><a href="#webpack配置统一管理" class="headerlink" title="webpack配置统一管理"></a>webpack配置统一管理</h4><p>自定义vue-cli插件的另一个好处就是，我们可以统一管理所有项目的webpack配置。</p><p>使用vue-cli初始化的项目，在项目的根目录下都会有一个vue.config.js，在这个文件里可以扩展webpack的配置。但是我们为了方便统一维护webpack，把所有需要扩展的webpack配置全部放到插件里去完成。</p><p>比如：</p><ol><li>统一给所有css变量加上一个默认值，这样就算不支持css变量的浏览器，也可以用默认值</li><li>统一的babel配置</li><li>统一微应用的构建方案</li></ol><h4 id="基础代码复用"><a href="#基础代码复用" class="headerlink" title="基础代码复用"></a>基础代码复用</h4><p>由于所有项目里都装了我们自己开发的vue-cli插件，所以我们把所有需要复用的代码，全部放到vue-cli里的lib文件夹下，然后在插件里配置一个webpack的alias指向这个文件夹，方便在项目里引用</p><h3 id="自建npm镜像"><a href="#自建npm镜像" class="headerlink" title="自建npm镜像"></a>自建npm镜像</h3><p>不是所有的npm包都能发布到npm官方镜像的，为了满足团队内部需要发布npm包的需求，我们用<a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a>搭建了自己的npm镜像，到现在用了一年多了，一直很稳定。</p><p>自建的npm镜像，也给我们复用代码提供了非常多的帮助，我们有很多功能都是以npm包发布在自己的npm镜像里，比如：</p><ol><li>编辑器相关的</li><li>前面提到的组件库</li><li>基于开源项目修改之后发布的包，以满足我们自己的需求</li></ol><h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><p>为了避免应用之间的样式影响，我们分别从规范和技术上做了规避</p><h3 id="BEM规范"><a href="#BEM规范" class="headerlink" title="BEM规范"></a>BEM规范</h3><p>所有应用，包括我们的组件库，必须使用<a href="http://getbem.com/" target="_blank" rel="noopener">BEM</a>规范进行样式开发，这样在写代码的时候，就已经尽量避免了样式的相互影响。</p><h3 id="动态添加-移除样式"><a href="#动态添加-移除样式" class="headerlink" title="动态添加/移除样式"></a>动态添加/移除样式</h3><p>我们的子应用在打包的时候，并不会单独把css文件提取出来，考虑到css的体积并不大，css会随着js文件一起发布，后面插入到页面的style标签里.</p><p>我们改造了一下vue官方提供的vue-style-loader，支持往style标签上生成自定义的属性.</p><p><img src="single-spa-id.jpg" alt="single-spa-id"></p><p>我们会往style标签上添加一个名为: data-single-spa-id的属性，它的值是一个每次构建的时候都会生成的随机值，而这个随机值会通过webpack的define插件，定义成一个全局变量，这样我们在子应用里也能拿到这个随机值，然后就能在子应用挂载和销毁的时候动态的添加/移除样式，进一步避免样式影响。动态添加/移除的代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'./i18n'</span></span><br><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"><span class="keyword">let</span> styleCache</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="built_in">document</span>.querySelector(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">if</span> (styleCache) &#123;</span><br><span class="line">      styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">        head.appendChild(style)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 移除掉所有的style</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    styleCache = [...document.querySelectorAll(<span class="string">`style[data-single-spa-id="<span class="subst">$&#123;SINGLE_SPA_ID&#125;</span>"]`</span>)]</span><br><span class="line">    styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">      style.parentNode.removeChild(style)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  addStyle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  removeStyle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，样式的动态添加/移除是和子应用的挂载和销毁逻辑在一起的，代码里的<code>SINGLE_SPA_ID</code>就是通过webpack的define插件定义的全局变量</p><h2 id="构建和发布"><a href="#构建和发布" class="headerlink" title="构建和发布"></a>构建和发布</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="构建SystemJs能识别的包"><a href="#构建SystemJs能识别的包" class="headerlink" title="构建SystemJs能识别的包"></a>构建SystemJs能识别的包</h4><p>前面我们提到systemJs，systemJs是一个前端的包管理器，它支持加载线上的js代码，但是对发布的代码有一些要求，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.register([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>需要用System.register对代码进行包裹</p><p>我们找到了一个webpack插件：<a href="https://github.com/CanopyTax/webpack-system-registe" target="_blank" rel="noopener">webpack-system-register</a>，它会自动给入口文件包裹上System.register，但是这个插件已经很久没有更新了，且这个插件也有些问题，比如：</p><ol><li>如果webpack的entry里的某一项是个数组，他无法正常处理</li><li>有的时候无法正常识别入口文件，导致把非入口代码也给加上了System.register</li></ol><p>我们自己对这个插件进行了修改，发布在了自己的npm镜像里</p><h4 id="对html文件的处理"><a href="#对html文件的处理" class="headerlink" title="对html文件的处理"></a>对html文件的处理</h4><p>由于子应用发布时候不需要Html文件，所以我们在构建的时候，需要把html相关的插件删掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api.chainWebpack(<span class="function">(<span class="params">webpackChain</span>) =&gt;</span> &#123;</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'html'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>Systemjs可以自动识别html代码里定义的<code>systemjs-importmap</code>，如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"systemjs-importmap"</span> <span class="attr">src</span>=<span class="string">"importmap.json"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>importmap.json</code>需要是一个线上的json文件地址，其数据格式大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"imports"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: <span class="string">"https://cdn/xxx.xxx.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个json文件有什么作用呢，需要结合我们在前面讲到子应用注册的一部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个loadApp方法，当你调用<code>loadApp(&#39;doc&#39;)</code>的时候，SystemJs会找到那个json文件里对应的子应用的对应的线上js代码地址，然后加载，最后把js代码暴露成一个变量app，这个app需要暴露我们前面提到的single-spa挂载和销毁子应用需要的3个方法:bootstrap, mount, unmount</p><p>所以我们现在的发布逻辑就变得很清晰了，只要想办法，在应用构建之后，把构建出来的文件推到CDN上面，同时修改<code>importmap.json</code>文件里对应的子应用的地址即可</p><p>基于此，我们自己开发了一个<code>update-server</code>用来负责子应用的发布和更新，子应用在发布的时候，会调<code>update-server</code>提供的接口，把json文件里的地址更新到最新版</p><h2 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h2><p>写到这里，还只字未提我们是怎么开发的。</p><p>大部分的微前端架构都会面临一个问题：微前端大多是一个主应用 + 若干个子应用的模式，子应用基本上都会依赖主应用提供的一些环境和数据，就像前面说的，我们为什么要打通backbone和vue之间的数据，也是这个原因，也就是说，如果没有主应用的环境，子应用就跑不起来，而如果要开发子应用还必须启动主应用，在开发体验上必然会大打折扣。</p><p>所以我们的解决方案是，在vue-cli插件里模拟主应用的环境。</p><p>前面有提到，在vue-cli插件里有一个lib文件夹，专门用来放需要复用的代码。前面提到的为了打通backbone和vue之间的数据而开发的中间层，需要在vue-cli插件里写一些代码来封装这个中间层的代码。</p><p>为什么要这么要封装呢？这样可以做到子应用对环境的无感，子应用不用在意自己是不是在主应用里运行，子应用只用调用这个封装之后的接口，至于运行环境，在封装这一层去判断。</p><p>这层封装做了这些事：</p><ol><li><p>如果在主应用里运行，则直接调用中间层提供的缓存数据，直接返回给子应用</p></li><li><p>如果子应用是单独在运行，则需要去调用相关的接口，拉取到数据，然后返回给子应用</p></li></ol><p>封装那一层做的事情，对子应用是无感的，子应用只管调封装之后的接口就行</p><h3 id="如何切换调试环境"><a href="#如何切换调试环境" class="headerlink" title="如何切换调试环境"></a>如何切换调试环境</h3><p>前面我们通过在vue-cli插件里做了一层封装，让子应用可以脱离主应用进行开发，但是难免有的时候是需要接入到主应用里进行调试的，那这个时候怎么办呢？</p><p>我们利用环境变量进行区分，vue-cli支持在项目的根目录下定义<code>.env.</code>开头的文件，可以直接在这些文件里写环境变量，</p><p>在开发子应用的时候，只要在<code>.env.local</code>里配置上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RISHIQING_SINGLE_SPA=false # 可配置为true，构建在主应用里调试需要的代码</span><br></pre></td></tr></table></figure><p>当<code>RISHIQING_SINGLE_SPA</code>为true的时候，就会构建出一个适合SystemJs引入的js包，这样方便在主应用里调试</p><p>当<code>RISHIQING_SINGLE_SPA</code>为false的时候，也是默认值，表示子应用需要独立开发</p><p>除了前面说的获取基础数据的方式不一样之外，这两种环境最大的区别就是，<code>RISHIQING_SINGLE_SPA</code>为true的时候，不会构建出html，而<code>RISHIQING_SINGLE_SPA</code>为false的时候，由于需要独立调试，则需要构建html。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，关于日事清的微前端实践先写到这里了，有很多章节其实是很复杂的，但是要在一篇文章里写完，还是有难度。微前端不是银弹，适合的才是最好的。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><h2 id="为什么没有共享基础库，比如vue-axios-vuex等"><a href="#为什么没有共享基础库，比如vue-axios-vuex等" class="headerlink" title="为什么没有共享基础库，比如vue, axios, vuex等?"></a>为什么没有共享基础库，比如vue, axios, vuex等?</h2><p>开始是有做相关开发的，但是在开发过程中，我们发现，不同的子应用，依赖的版本号会不同，如果强制统一，很容易出问题。但是这样也带来了一个问题，就是会增加代码体积。我们会在后面各子应用逐渐稳定之后，想办法进行复用</p><h2 id="项目拆分成微前端之后，如果进行代码管理？"><a href="#项目拆分成微前端之后，如果进行代码管理？" class="headerlink" title="项目拆分成微前端之后，如果进行代码管理？"></a>项目拆分成微前端之后，如果进行代码管理？</h2><p>微前端架构虽然给前端项目带来了更多可能性，但也带来了维护上的困难。就拿我上面提到的vue-cli插件，我们现在的子应用有十几个，一旦插件有更新，就得在十几个项目里进行更新，非常麻烦。后续我们可能会引入<a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a>再把所有微应用放到一个仓库里进行管理，来解决包的依赖问题。俗话说分久必合，合久必分，大概就是这个理吧。</p><h2 id="对这次重构有什么想说的？"><a href="#对这次重构有什么想说的？" class="headerlink" title="对这次重构有什么想说的？"></a>对这次重构有什么想说的？</h2><p>业务的发展是技术的助推剂，一切技术的更新都源于对业务场景的思考</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="微前端" scheme="https://nodepie.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
      <category term="singleSpa" scheme="https://nodepie.com/tags/singleSpa/"/>
    
      <category term="vue" scheme="https://nodepie.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>代码审查的正确姿势</title>
    <link href="https://nodepie.com/2018/05/29/code-review/"/>
    <id>https://nodepie.com/2018/05/29/code-review/</id>
    <published>2018-05-29T12:55:42.000Z</published>
    <updated>2021-04-06T04:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这是一个很久之前我就想在前端团队里推的一个事情，基于这么几个原因吧:</p><ol><li>一直以来，前端的代码审查都是我一个人在做，仅仅是关注大家对公共文件的修改，还有就是一些明显的逻辑问题，但其实大部分问题靠我一个人是发现不了的</li><li>我们自己总是容易陷入逻辑怪圈，在写代码的时候，很难发现自己的问题，但是看别人的代码的时候，往往比较挑剔，更容易发现别人的问题</li><li>促进我们的日常代码交流，吸收别人的优秀经验</li><li>当你知道某个人会审查你的代码的时候，你会更加严格要求自己</li><li>培养我们写出优秀代码的习惯，实现团队和个人的共同进步</li><li>我们需要更加关注代码的质量</li><li>Code Review可以有效的和重构相结合，给我们重构提供有力证据，推动我们进行重构工作</li></ol><h2 id="审查些什么"><a href="#审查些什么" class="headerlink" title="审查些什么"></a>审查些什么</h2><h3 id="审查清单"><a href="#审查清单" class="headerlink" title="审查清单"></a>审查清单</h3><p>如果你所在的团队和我们一样，也刚开始做Code Review，对代码审查到底应该审查些什么感到茫然，在网上搜了很多审查清单，发现非常零碎，也不知道哪些应该遵守，哪些不应该遵守。我的建议是，可以根据团队现有的开发情况，自己大概整理一份审查清单，也不用太完整，只要建立好完整的整理机制，在实施Code Review的过程中，自己总结提炼，以及修改维护之前的审查清单，这样在完善审查清单的过程中，也对健全团队的Code Review机制非常有帮助，让团队成员对新增的审查清单更加有认同感。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>到底要不要在代码审查的时候审查代码的格式，都各说不一。个人觉得代码格式不应该成为代码审查重要的关注点，格式问题，更多应该是靠开发者自己去发现解决，借eslint和sass-lint这类工具辅助，以及团队的代码规范，在提交审核之前就应该做到没有问题。代码审查本来就是为了审核功能的实现方式，代码的组织形式等等有没有更优解，但也不是说完全不关注，如果发现了格式问题，还是需要提出来。</p><h3 id="审查形式"><a href="#审查形式" class="headerlink" title="审查形式"></a>审查形式</h3><p>总体来说，代码审查有两种形式，小片段式和大规模式</p><h4 id="小片段式"><a href="#小片段式" class="headerlink" title="小片段式"></a>小片段式</h4><p>小片段式的代码审查，又称事前审查，是在代码合并到主分支之前就做的一种审查形式。如果发现了问题，在代码合并之前就会进行需改。这种形式可以直接在线上进行，代码提交者和审查者可完全线上进行交流。</p><h4 id="大规模式"><a href="#大规模式" class="headerlink" title="大规模式"></a>大规模式</h4><p>大规模式的代码审查，又称事后审查，团队可以每两个星期或者一个月组织一次大模块式的Code Review会议，大家在会上进行大规模的代码检视，提出问题并记录，之后可以以重构的方式来处理在会议上发现的问题.</p><h4 id="哪种形式更好"><a href="#哪种形式更好" class="headerlink" title="哪种形式更好"></a>哪种形式更好</h4><p>这两种形式各有各的好处，小片段式的方式让我们可以在审查较小代码量的情况下就能进行，并且可以在代码合并之前进行，这样可以提前发现一些bug，而大规模式可以几个人一起在会议上站在一个更高的层面去审核代码，彼此交流开发经验。我推荐是小片段式和大规模式相结合。</p><h3 id="怎么审查"><a href="#怎么审查" class="headerlink" title="怎么审查"></a>怎么审查</h3><h4 id="审查工具"><a href="#审查工具" class="headerlink" title="审查工具"></a>审查工具</h4><p>我们的代码管理用的github，github提供了非常棒的Code Review功能。利用github提供的pull request模板功能，让代码提交者根据这个模板去填写每次提交pull request需要的信息。另外github的markdown支持checkbox，我们可以把一些非常重要的，每次都需要检视的审查项列到模板里去，这样提交者就可以按照这个列表自己提前检查一遍，也可以减少审查者的工作。下面是我们现在用的一个模板<br><img src="pull_request_template.md.png" alt="pull request 模板"><br>前面6个checkbox，是提交者每次都必须自查一遍，然后打钩，这6个checkbox不打完钩，就不会进入正常的审查流程，最后一个checkbox是审查者在审查完了之后打钩，表示这个pull request没问题，可以进行合并。如果团队的代码审查和代码合并不是同一个人，那么负责合并的人可以在pull request列表里看到每个pull request的进度，如下图<br><img src="pull_request_item.png" alt="pull request item"><br>如果所有checkbox已经完成，表示这个pull request可以进行合并</p><h4 id="通知工具"><a href="#通知工具" class="headerlink" title="通知工具"></a>通知工具</h4><p>用了github，当然是用github强大的邮件通知功能了。为了防止常用邮箱的通知爆炸，可以专门注册一个邮箱来接收github的邮件通知。推荐使用网易邮箱客户端，它有邮件分类功能，可以做到只通知部分邮件，防止打扰。</p><h2 id="代码审查的一些心得"><a href="#代码审查的一些心得" class="headerlink" title="代码审查的一些心得"></a>代码审查的一些心得</h2><ol><li>作为审查者，你需要知道你在给谁review代码</li><li>每个pull request应该尽可能的小，这样才能快速且安全的review</li><li>开放心态，虚心接受别人提的意见，要么采纳，要么说出自己反驳的理由</li><li>我们是人，不是机器，是人就会犯错，很正常</li><li>对公共文件的修改需要加倍关注，这些代码一旦出问题，会导致严重的错误</li></ol><h2 id="附上我们团队代码审查的流程图"><a href="#附上我们团队代码审查的流程图" class="headerlink" title="附上我们团队代码审查的流程图"></a>附上我们团队代码审查的流程图</h2><p><img src="flow.svg" alt="流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="code review" scheme="https://nodepie.com/tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>前端技术之eslint初夜</title>
    <link href="https://nodepie.com/2015/11/03/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8Beslint%E5%88%9D%E5%A4%9C/"/>
    <id>https://nodepie.com/2015/11/03/前端技术之eslint初夜/</id>
    <published>2015-11-03T07:49:26.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置ESLint"><a href="#配置ESLint" class="headerlink" title="配置ESLint:"></a>配置ESLint:</h3><ol><li><strong>Configuration Comments</strong> - use JavaScript comments to embed configuration information directly into a file</li><li><strong>Configuration Files</strong></li></ol><h3 id="几个可配置的参数"><a href="#几个可配置的参数" class="headerlink" title="几个可配置的参数"></a>几个可配置的参数</h3><ul><li><strong>Environments</strong> - 代码运行的环境,不同环境都有不同的默认配置。</li><li><strong>Globals</strong> - 在执行的时候需要的一些全局变量。</li><li><strong>Rules</strong> - 启用哪些规则，错误级别是什么。</li></ul><h3 id="定义js语言特性-ES5-ES6"><a href="#定义js语言特性-ES5-ES6" class="headerlink" title="定义js语言特性(ES5/ES6)"></a>定义js语言特性(ES5/ES6)</h3><blockquote><p>在<code>ecmaFeatures</code>属性里，定义相应的js特性</p></blockquote><ul><li>arrowFunctions - 箭头函数</li><li>binaryLiterals - enable binary literals</li><li>blockBindings - enable let and const (aka block bindings)</li><li>classes - enable classes</li><li>defaultParams - enable default function parameters</li><li>destructuring - enable destructuring</li><li>forOf - enable for-of loops</li><li>generators - enable generators</li><li>modules - enable modules and global strict mode</li><li>objectLiteralComputedProperties - enable computed object literal property names</li><li>objectLiteralDuplicateProperties - enable duplicate object literal properties in strict mode</li><li>objectLiteralShorthandMethods - enable object literal shorthand methods</li><li>objectLiteralShorthandProperties - enable object literal shorthand properties</li><li>octalLiterals - enable octal literals</li><li>regexUFlag - enable the regular expression u flag</li><li>regexYFlag - enable the regular expression y flag</li><li>restParams - enable the rest parameters</li><li>spread - enable the spread operator for arrays</li><li>superInFunctions - enable super references inside of functions</li><li>templateStrings - enable template strings</li><li>unicodeCodePointEscapes - enable code point escapes</li><li>globalReturn - allow return statements in the global scope</li><li>jsx - JSX</li><li>experimentalObjectRestSpread - enable support for the experimental object rest/spread properties (IMPORTANT: This is an experimental feature that may change significantly in the future. It’s recommended that you do not write rules relying on this functionality unless you are willing to incur maintenance cost when it changes.)</li></ul><p>示例代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ecmaFeatures"</span>: &#123;</span><br><span class="line">        <span class="attr">"blockBindings"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"forOf"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Specifying-Parser"><a href="#Specifying-Parser" class="headerlink" title="Specifying Parser"></a>Specifying Parser</h3>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;配置ESLint&quot;&gt;&lt;a href=&quot;#配置ESLint&quot; class=&quot;headerlink&quot; title=&quot;配置ESLint:&quot;&gt;&lt;/a&gt;配置ESLint:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Configuration
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术之怎么在chrome里批量下载base64图片</title>
    <link href="https://nodepie.com/2015/10/13/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%80%8E%E4%B9%88%E5%9C%A8chrome%E9%87%8C%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbase64%E5%9B%BE%E7%89%87/"/>
    <id>https://nodepie.com/2015/10/13/前端技术之怎么在chrome里批量下载base64图片/</id>
    <published>2015-10-13T12:10:41.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>新任务，在chrome里批量下载base64编码的图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes=<span class="built_in">window</span>.atob(base64Str.split(<span class="string">","</span>)[<span class="number">1</span>]);<span class="comment">//base64Str是base64编码的字符串</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length);</span><br><span class="line"><span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] = bytes.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Blob( [ab] , &#123;<span class="attr">type</span> : <span class="string">'image/png'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> url = url = URL.createObjectURL(image);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);<span class="comment">//这里建一个a标签，用于下面下载图片</span></span><br><span class="line">a.href = url;</span><br><span class="line">a.download = fileName;<span class="comment">//fileName是下载的图片名称</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">e.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">a.dispatchEvent(e);<span class="comment">//触发点击事件，开始下载</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;新任务，在chrome里批量下载base64编码的图片。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于ionic在ios9中出现的问题</title>
    <link href="https://nodepie.com/2015/10/13/%E5%85%B3%E4%BA%8Eionic%E5%9C%A8ios9%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/13/关于ionic在ios9中出现的问题/</id>
    <published>2015-10-13T12:02:36.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>[$rootScope:infdig] 10 $digest() iterations reached. Aborting!</span><br><span class="line">Watchers fired in the last 5 iterations: []</span><br></pre></td></tr></table></figure><p>该问题会导致页面的路由出问题，导致页面之间的切换出现异常，鬼火了很久。</p><p>需下载补丁：</p><p><a href="https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js" target="_blank" rel="noopener">https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js</a></p><p>在app.js（启动js）中应用模块：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'ngIOS9UIWebViewPatch</span>'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端的工程问题和技术问题</title>
    <link href="https://nodepie.com/2015/10/06/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E5%92%8C%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/06/前端的工程问题和技术问题/</id>
    <published>2015-10-06T09:23:06.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>做过前端开发一定时间的同学都知道，前端的难点主要集中在两点：工程问题和技术问题。工程问题主要涉及到一系列自动化的问题，比如自动化测试，自动化集成，自动化部署等等；技术问题主要针对前端具体的开发问题了，比如浏览器兼容，页面性能，按需加载等等。</p><p>博主到现在对这些问题也只是了解个皮毛，还需要在接下来的日子和各位同学们一起深入研究探讨。</p><p>之后关于工程方面的问题，都会以<code>前端工程之***</code>为题展开，而关于技术方面的问题，则会以<code>前端技术之***</code>为题展开。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql地理空间使用</title>
    <link href="https://nodepie.com/2015/08/06/mysql%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/08/06/mysql地理空间使用/</id>
    <published>2015-08-06T03:17:49.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat</p><h3 id="创建地理空间数据表"><a href="#创建地理空间数据表" class="headerlink" title="创建地理空间数据表"></a>创建地理空间数据表</h3><p>要使用空间索引，表的类型要选择成MyISAM,貌似表的默认类型就是这个，但是有时候还是需要手动去改。如图</p><p><img src="navicat-1.png" alt="数据表"></p><h3 id="创建地理空间字段"><a href="#创建地理空间字段" class="headerlink" title="创建地理空间字段"></a>创建地理空间字段</h3><p>在我使用的navicat版本里面，创建字段的时候，type一栏里并没有关于地理空间的类型，需要手动输入.常用的类型有：</p><ul><li>GEOMETRY</li><li>POINT</li><li>LINESTRING</li><li>POLYGON</li><li>MULTIPOINT</li><li>MULTILINESTRING</li><li>MULTIPOLYGON</li><li>MULTIPOLYGON</li></ul><h3 id="连接数据库需要注意"><a href="#连接数据库需要注意" class="headerlink" title="连接数据库需要注意"></a>连接数据库需要注意</h3><p>使用以下方式连接.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.31.202 -u root -p -D learndrive <span class="comment">#learndrive是数据库的名称</span></span><br></pre></td></tr></table></figure><h3 id="创建地理空间索引"><a href="#创建地理空间索引" class="headerlink" title="创建地理空间索引"></a>创建地理空间索引</h3><p>在navicat里面无法直接创建SPATIAL索引，需要到shell里用命令行创建.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SPATIAL INDEX sp_index ON site (location); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>连接上mysql之后，直接用上面的代码创建索引，很可能会报错（是对已有的表创建索引造成）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1416 (22003): Cannot get geometry object from data you send to the GEOMETRY field</span><br></pre></td></tr></table></figure><p>先把地理空间字段的值对边填一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `site` SET `location` = POINT( 0,0 ); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>然后再创建索引.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat&lt;/p&gt;
&lt;h3
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.gitlab-ci.yml使用</title>
    <link href="https://nodepie.com/2015/07/09/gitlab-ci-yml%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/07/09/gitlab-ci-yml使用/</id>
    <published>2015-07-09T02:48:50.000Z</published>
    <updated>2020-03-02T11:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>gitlab-ci</code>确实有点坑，为了使用它的runner自动执行<code>shell</code>，然后编译，折腾了一两天，最后发现，呵呵，问题就这样稀里糊涂被解决了.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在工程的根目录添加了<code>.gitlab-ci.yml</code>文件之后,gitlab-ci build的状态每次都是pending，各种搜google，各种stackoverflow，都找不到解决办法。</p><h3 id="gitlab-ci-yml文件内容"><a href="#gitlab-ci-yml文件内容" class="headerlink" title=".gitlab-ci.yml文件内容"></a>.gitlab-ci.yml文件内容</h3><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>最后实在没办法，把之前的runner删了，重新建了一个runner，在提示需要哪个通道的时候，选择shell。</p><h3 id="新建runner的脚本"><a href="#新建runner的脚本" class="headerlink" title="新建runner的脚本"></a>新建runner的脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~gitlab_ci_multi_runner</span><br><span class="line">gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. http://gitlab-ci.org:3000/ )</span><br><span class="line">https://ci.gitlab.org/</span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx</span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">docker</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">ruby:2.1</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but <span class="keyword">if</span> it<span class="string">'s running already the config should be automatically reloaded!</span></span><br></pre></td></tr></table></figure><h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2><p><img src="gitlab-ci.png" alt="Resize icon"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="gitlab,gitlab-ci" scheme="https://nodepie.com/tags/gitlab-gitlab-ci/"/>
    
  </entry>
  
</feed>
