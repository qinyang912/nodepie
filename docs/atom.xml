<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nodepie</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nodepie.com/"/>
  <updated>2020-03-10T05:29:37.322Z</updated>
  <id>https://nodepie.com/</id>
  
  <author>
    <name>Qin Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微前端实践</title>
    <link href="https://nodepie.com/2020/03/02/%E6%97%A5%E4%BA%8B%E6%B8%85%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/"/>
    <id>https://nodepie.com/2020/03/02/日事清的微前端之路/</id>
    <published>2020-03-02T13:15:37.000Z</published>
    <updated>2020-03-10T05:29:37.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>日事清的web端从诞生之初就一直用的backbone进行开发，当时的包管理器还用的require.js，构建方案还是grunt。后来在2016年，我们把构建方案换成了webpack，但是考虑到整个团队的学习成本，也考虑到项目的稳定性，再加上为了快速上线，视图框架还是用的Backbone，这个架构也就一直用到现在。</p><p>我们也鼓励团队成员用vue开发新的项目，在对比backbone和vue的开发效率的时候，我们发现，vue的效率高的不止一点点，且开发体验要比backbone好太多，所以什么时候能把backbone换成vue一直是我们的心愿。但没有业务场景，且现在项目又稳定，我们是绝不可能轻易迈出这一步的。</p><p>机会出现在了2019年10月份，日事清web端准备大版本迭代，新版的设计图和之前的几乎完全不一样，新增了非常多的功能，已有功能也做了非常多的优化。经过讨论，我们决定对项目进行重构，重构就意味着我们有机会引入新技术。</p><p>但是此次重构有点特别，如果用过日事清的小伙伴应该知道，日事清分：日程，计划，笔记，应用，公司5个模块，但日程不参与此次重构，其他几个模块都需要分批进行重构，且最好是重构完一个模块，就上线一个模块。也就是说，如果我们想用vue来重构，必须要backbone和vue共存一段时间，然后再逐步把所有的backbone替换掉。</p><p><img src="rishiqing-module.jpg" alt="rishiqing-module.jpg"></p><p>最终我们决定引入微前端的架构，选择微前端可以非常好的解决这次重构遇到的问题：</p><ol><li>多个技术框架可共存使用，即使用vue不会对已有的backbone造成影响</li><li>可灵活的进行渐进式重构</li><li>进行重构的模块可以选择新的技术方案</li><li>后续重构的模块可独立发布</li></ol><h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><p>目前业界比较成熟的微前端方案主要是两种：iframe和singleSpa</p><p>iframe:</p><p>日事清之前有部分功能就是用iframe的方式嵌套在页面里的，但是这种嵌套的方式有很多限制：</p><ol><li>iframe内部的事件不能冒泡出来，导致很多交互都需要postMessage来对接，非常麻烦</li><li>ifame内部的全局弹窗不能全尺寸弹出，影响用户体验</li></ol><p>singleSpa:</p><p>开源项目<a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>，它的实现思路是：一个主应用和若干个子应用</p><p>​    主应用：负责子应用的注册、挂载和销毁</p><p>​    子应用：提供三个接口：bootstrap, mount, unmount供主应用调用</p><p>我们最终选择了singleSpa，主要原因是：</p><ol><li>子应用可以挂载在主应用的某个元素下面，可以和主应用共享一个执行环境</li><li>子应用的注册、挂载和销毁逻辑相对简单，如果放到脚手架里，所有子项目都可以共用</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="路由管理-amp-子应用注册"><a href="#路由管理-amp-子应用注册" class="headerlink" title="路由管理 &amp; 子应用注册"></a>路由管理 &amp; 子应用注册</h2><p>我们需要管理3部分的路由：</p><ol><li>原有的backbone路由</li><li>singleSpa注册子应用的路由</li><li>子应用内部的路由</li></ol><p>我们原有的backbone的路由的对应关系是这样的：</p><table><thead><tr><th style="text-align:left">模块</th><th>路由</th></tr></thead><tbody><tr><td style="text-align:left">日程</td><td>/app/todo</td></tr><tr><td style="text-align:left">计划</td><td>/app/kanban</td></tr><tr><td style="text-align:left">笔记</td><td>/app/doc</td></tr><tr><td style="text-align:left">应用</td><td>/app/application</td></tr><tr><td style="text-align:left">公司</td><td>/app/company</td></tr></tbody></table><p>这次除了日程模块之外，其他几个模块都会重构，也即其他几个模块的路由都不走backbone。</p><p>singleSpa支持通过路由的方式来判断是否挂载子应用，且引入singleSpa并不会影响backbone的路由的正常工作，所以我们只用把日程之外的其他几个模块的路由从backbone移除，然后把其他几个模块当做子应用注册到singleSpa即可。</p><p>以注册笔记模块为例，下面是注册部分的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> singleSpa <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lifecycleFn = [<span class="string">'bootstrap'</span>, <span class="string">'unmount'</span>, <span class="string">'mount'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTAINER_CACHE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一下子应用暴露的方法，至少保证生命周期函数是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapLifecycle</span> (<span class="params">life = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!life) life = &#123;&#125;;</span><br><span class="line">  lifecycleFn.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!life[method] || <span class="keyword">typeof</span> life[method] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      life[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> life;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span> (<span class="params">containerId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  container.id = containerId;</span><br><span class="line">  <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 应用名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>options 可选配置参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.containerId 元素容器的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>options.appPath 元素的路径，如果不传则默认为 /app/$&#123;name&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerApplication</span> (<span class="params">name, options</span>) </span>&#123;</span><br><span class="line">  singleSpa.registerApplication(name, loadApp(name), (location) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> appPath = options.appPath || <span class="string">`/app/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> active = location.pathname.startsWith(appPath);</span><br><span class="line">    <span class="keyword">if</span> (active) &#123;</span><br><span class="line">      <span class="comment">// 这里之所以这样做，是因为这个方法可能会被执行多次，为了防止container重复创建</span></span><br><span class="line">      <span class="keyword">if</span> (!CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        <span class="keyword">const</span> container = createContainer(options.containerId);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">        CONTAINER_CACHE[name] = container;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (CONTAINER_CACHE[name]) &#123;</span><br><span class="line">        CONTAINER_CACHE[name].parentElement.removeChild(CONTAINER_CACHE[name]);</span><br><span class="line">      &#125;</span><br><span class="line">      CONTAINER_CACHE[name] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    containerId: options.containerId</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注册笔记</span></span><br><span class="line">  registerApplication(<span class="string">'doc'</span>, &#123;</span><br><span class="line">    containerId: <span class="string">'doc-container'</span></span><br><span class="line">    appPath: <span class="string">'/app/doc'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  singleSpa.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当有路由变化的时候，singleSpa.registerApplication的第三个参数就会执行，然后判断路径是否是<code>/app/doc</code>开头的，如果是，则说明需要挂载笔记这个子应用。</p><p>在判断可以挂载子应用之后，主应用会创建一个Div容器，然后把这个容器传给子应用，子应用在执行挂载逻辑的时候，就会把整个应用都挂载在这个Div里面。</p><p>大家可能有注意到，代码里有用到一个全局变量System，这个是<a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">systemjs</a>暴露出来的，用来加载线上的js模块，后面讲怎么发布的时候会详细讲到。</p><p>在笔记子应用里需要暴露出single-spa挂载和销毁要用到的三个周期函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 启动函数</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-empty-function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  vueContainer = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;props.containerId&#125;</span>`</span>)</span><br><span class="line">  el.appendChild(vueContainer.$el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vueContainer) &#123;</span><br><span class="line">    vueContainer.$destroy()</span><br><span class="line">    <span class="keyword">if</span> (vueContainer.$el.parentElement) &#123;</span><br><span class="line">      vueContainer.$el.parentElement.removeChild(vueContainer.$el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mount的时候初始化子应用的入口vue组件，并挂载到主应用那边传过来的一个div下面</p><p>在unmount的时候，执行$destroy，销毁应用</p><p>上面提到，我们需要管理3部分路由，最后一部分子应用内部的路由，就在这里mount的时候直接初始化了。之后只要在这个子应用里的路由跳转，都能经过vue-router进行处理。</p><h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>数据层是一个非常庞大且复杂的话题，限于篇幅，简单讲一下我们的数据层是怎么设计的.</p><h3 id="打通backbone和vue之间的数据"><a href="#打通backbone和vue之间的数据" class="headerlink" title="打通backbone和vue之间的数据"></a>打通backbone和vue之间的数据</h3><p>在考虑数据层怎么设计的时候，遇到的第一个问题是：我们的主应用是基于backbone开发的，数据管理是backbone提供的collection和model，但是我们的子应用是用vue进行开发，要怎么打通backbone和vue之间的数据进行共享。</p><p>在解决这个问题的时候，我们都有一个共识，首先需要保证原有的backbone的数据稳定，代码能不动的尽量不动，等所有模块都用vue重构完了之后，让backbone自然而然的退役。经过分析之后，我们发现主应用里需要共享的就这么几类数据：</p><ol><li>用户的基础数据</li><li>组织架构数据</li><li>websocket实时推送数据</li></ol><p>用户基础数据和组织架构数据每个子应用都会用到，为了避免子应用再调接口去获取这些数据，需要想办法把这两个数据共享出去</p><p>主应用里有用到websocket来接收实时数据，拆分之后的子应用也需要用到websocket，我们最终决定只在主应用里初始化webscoket连接，不在各子应用再建立webscoket，原因如下：</p><ol><li>需要建立websocket的子应用比较多，如果每个都单独建立，会增加服务器的压力</li><li>子应用会随着路由的变化而挂载或者销毁，会导致频繁的建立websocket</li><li>在主应用和子应用之间嫁接一个事件总线，当主应用收到实时数据之后，就在这个事件总线上触发一个事件，子应用只要挂载之后就订阅这个事件，这样子应用也能及时收到实时数据</li></ol><p>基于上面的考虑，我们设计了一个中间层，代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'eventemitter3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageClient = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础数据</span></span><br><span class="line"><span class="keyword">const</span> BasicData = &#123;</span><br><span class="line">  USER_INFO: &#123;&#125;,</span><br><span class="line">  USER_TREE: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setBasicData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(BasicData, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBasicData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BasicData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息客户端</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getMessageClient</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> messageClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往消息客户端发送消息(ws实时消息)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  messageClient.emit(<span class="string">'message'</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主应用在初始化了之后，调用<code>setBasicData</code>把用户基础数据和组织架构数据放到BasicData里缓存起来，每个子应用初始化之后，只要调用<code>getBasicData</code>，即可获取到基础数据，而不用再调接口</p><p>主应用在收到websocket数据之后，调用<code>sendMessage</code>往事件总线上触发一个<code>message</code>事件，子应用只要通过<code>getMessageClient</code>拿到这个消息客户端，然后订阅<code>message</code>事件，即可收到实时数据，子应用销毁之后，取消订阅即可</p><h3 id="vue内部的数据管理"><a href="#vue内部的数据管理" class="headerlink" title="vue内部的数据管理"></a>vue内部的数据管理</h3><p>子应用里有用到<a href="https://rxdb.info/" target="_blank" rel="noopener">Rxdb</a>做数据管理，这里就不展开了，有机会今后可以另外写一篇</p><h2 id="组件-amp-代码复用"><a href="#组件-amp-代码复用" class="headerlink" title="组件&amp;代码复用"></a>组件&amp;代码复用</h2><p>引入微前端架构之后，面临着一个非常大的问题：所有子应用都被拆分成独立的仓库进行独立维护了，那怎么进行代码和组件的复用?</p><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>好在我们从19年初就有意识的在开发我们内部的组件库，基于业务需要，我们在开发自己的组件库的时候把组件分成了两类：</p><ol><li>基础组件</li><li>业务组件</li></ol><p>基础组件主要包括: button, icon, popover, modal, tree这种通用组件</p><p>业务组件主要包括：成员选择器，日期选择器这种业务强相关的组件</p><p>我们的子应用都是基于我们自己的组件库进行开发的，组件库支持按需引入，尽量减少代码体积</p><h3 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h3><p>vue-cli的脚手架在我们这次重构过程中起到了非常大的作用，它的作用仅次于我们的组件库。</p><p>用过vue-cli的同学应该都知道，vue-cli和普天之下的其他cli一样，支持代码模板，支持preset，也支持自定义插件。为了方便团队成员使用vue，我们在18年就开始开发自己的vue-cli插件，可快速初始化我们内部需要的各种项目。</p><p>使用脚手架的收益会逐年增大，尤其是当团队里需要开发的应用越来越多，收益会越来越大。</p><h4 id="快速初始化项目"><a href="#快速初始化项目" class="headerlink" title="快速初始化项目"></a>快速初始化项目</h4><p>我们把一个微应用需要用到的基础代码全部放到vue-cli插件里的generator里，使用插件，可快速创建一个满足我们自己需求的微应用。</p><h4 id="webpack配置统一管理"><a href="#webpack配置统一管理" class="headerlink" title="webpack配置统一管理"></a>webpack配置统一管理</h4><p>自定义vue-cli插件的另一个好处就是，我们可以统一管理所有项目的webpack配置。</p><p>使用vue-cli初始化的项目，在项目的根目录下都会有一个vue.config.js，在这个文件里可以扩展webpack的配置。但是我们为了方便统一维护webpack，把所有需要扩展的webpack配置全部放到插件里去完成。</p><p>比如：</p><ol><li>统一给所有css变量加上一个默认值，这样就算不支持css变量的浏览器，也可以用默认值</li><li>统一的babel配置</li><li>统一微应用的构建方案</li></ol><h4 id="基础代码复用"><a href="#基础代码复用" class="headerlink" title="基础代码复用"></a>基础代码复用</h4><p>由于所有项目里都装了我们自己开发的vue-cli插件，所以我们把所有需要复用的代码，全部放到vue-cli里的lib文件夹下，然后在插件里配置一个webpack的alias指向这个文件夹，方便在项目里引用</p><h3 id="自建npm镜像"><a href="#自建npm镜像" class="headerlink" title="自建npm镜像"></a>自建npm镜像</h3><p>不是所有的npm包都能发布到npm官方镜像的，为了满足团队内部需要发布npm包的需求，我们用<a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a>搭建了自己的npm镜像，到现在用了一年多了，一直很稳定。</p><p>自建的npm镜像，也给我们复用代码提供了非常多的帮助，我们有很多功能都是以npm包发布在自己的npm镜像里，比如：</p><ol><li>编辑器相关的</li><li>前面提到的组件库</li><li>基于开源项目修改之后发布的包，以满足我们自己的需求</li></ol><h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><p>为了避免应用之间的样式影响，我们分别从规范和技术上做了规避</p><h3 id="BEM规范"><a href="#BEM规范" class="headerlink" title="BEM规范"></a>BEM规范</h3><p>所有应用，包括我们的组件库，必须使用<a href="http://getbem.com/" target="_blank" rel="noopener">BEM</a>规范进行样式开发，这样在写代码的时候，就已经尽量避免了样式的相互影响。</p><h3 id="动态添加-移除样式"><a href="#动态添加-移除样式" class="headerlink" title="动态添加/移除样式"></a>动态添加/移除样式</h3><p>我们的子应用在打包的时候，并不会单独把css文件提取出来，考虑到css的体积并不大，css会随着js文件一起发布，后面插入到页面的style标签里.</p><p>我们改造了一下vue官方提供的vue-style-loader，支持往style标签上生成自定义的属性.</p><p><img src="single-spa-id.jpg" alt="single-spa-id"></p><p>我们会往style标签上添加一个名为: data-single-spa-id的属性，它的值是一个每次构建的时候都会生成的随机值，而这个随机值会通过webpack的define插件，定义成一个全局变量，这样我们在子应用里也能拿到这个随机值，然后就能在子应用挂载和销毁的时候动态的添加/移除样式，进一步避免样式影响。动态添加/移除的代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'./i18n'</span></span><br><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vueContainer</span><br><span class="line"><span class="keyword">let</span> styleCache</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="built_in">document</span>.querySelector(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">if</span> (styleCache) &#123;</span><br><span class="line">      styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">        head.appendChild(style)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 移除掉所有的style</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    styleCache = [...document.querySelectorAll(<span class="string">`style[data-single-spa-id="<span class="subst">$&#123;SINGLE_SPA_ID&#125;</span>"]`</span>)]</span><br><span class="line">    styleCache.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">      style.parentNode.removeChild(style)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 挂载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  addStyle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleSpa 卸载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  removeStyle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，样式的动态添加/移除是和子应用的挂载和销毁逻辑在一起的，代码里的<code>SINGLE_SPA_ID</code>就是通过webpack的define插件定义的全局变量</p><h2 id="构建和发布"><a href="#构建和发布" class="headerlink" title="构建和发布"></a>构建和发布</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="构建SystemJs能识别的包"><a href="#构建SystemJs能识别的包" class="headerlink" title="构建SystemJs能识别的包"></a>构建SystemJs能识别的包</h4><p>前面我们提到systemJs，systemJs是一个前端的包管理器，它支持加载线上的js代码，但是对发布的代码有一些要求，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.register([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>需要用System.register对代码进行包裹</p><p>我们找到了一个webpack插件：<a href="https://github.com/CanopyTax/webpack-system-registe" target="_blank" rel="noopener">webpack-system-register</a>，它会自动给入口文件包裹上System.register，但是这个插件已经很久没有更新了，且这个插件也有些问题，比如：</p><ol><li>如果webpack的entry里的某一项是个数组，他无法正常处理</li><li>有的时候无法正常识别入口文件，导致把非入口代码也给加上了System.register</li></ol><p>我们自己对这个插件进行了修改，发布在了自己的npm镜像里</p><h4 id="对html文件的处理"><a href="#对html文件的处理" class="headerlink" title="对html文件的处理"></a>对html文件的处理</h4><p>由于子应用发布时候不需要Html文件，所以我们在构建的时候，需要把html相关的插件删掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api.chainWebpack(<span class="function">(<span class="params">webpackChain</span>) =&gt;</span> &#123;</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'html'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line">  webpackChain.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>Systemjs可以自动识别html代码里定义的<code>systemjs-importmap</code>，如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"systemjs-importmap"</span> <span class="attr">src</span>=<span class="string">"importmap.json"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>importmap.json</code>需要是一个线上的json文件地址，其数据格式大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"imports"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: <span class="string">"https://cdn/xxx.xxx.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个json文件有什么作用呢，需要结合我们在前面讲到子应用注册的一部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadApp</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用SystemJs加载线上模块</span></span><br><span class="line">      System</span><br><span class="line">        .import(name)</span><br><span class="line">        .then(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle(app));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// js文件加载失败的时候，会执行这个报错</span></span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(wrapLifecycle());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个loadApp方法，当你调用<code>loadApp(&#39;doc&#39;)</code>的时候，SystemJs会找到那个json文件里对应的子应用的对应的线上js代码地址，然后加载，最后把js代码暴露成一个变量app，这个app需要暴露我们前面提到的single-spa挂载和销毁子应用需要的3个方法:bootstrap, mount, unmount</p><p>所以我们现在的发布逻辑就变得很清晰了，只要想办法，在应用构建之后，把构建出来的文件推到CDN上面，同时修改<code>importmap.json</code>文件里对应的子应用的地址即可</p><p>基于此，我们自己开发了一个<code>update-server</code>用来负责子应用的发布和更新，子应用在发布的时候，会调<code>update-server</code>提供的接口，把json文件里的地址更新到最新版</p><h2 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h2><p>写到这里，还只字未提我们是怎么开发的。</p><p>大部分的微前端架构都会面临一个问题：微前端大多是一个主应用 + 若干个子应用的模式，子应用基本上都会依赖主应用提供的一些环境和数据，就像前面说的，我们为什么要打通backbone和vue之间的数据，也是这个原因，也就是说，如果没有主应用的环境，子应用就跑不起来，而如果要开发子应用还必须启动主应用，在开发体验上必然会大打折扣。</p><p>所以我们的解决方案是，在vue-cli插件里模拟主应用的环境。</p><p>前面有提到，在vue-cli插件里有一个lib文件夹，专门用来放需要复用的代码。前面提到的为了打通backbone和vue之间的数据而开发的中间层，需要在vue-cli插件里写一些代码来封装这个中间层的代码。</p><p>为什么要这么要封装呢？这样可以做到子应用对环境的无感，子应用不用在意自己是不是在主应用里运行，子应用只用调用这个封装之后的接口，至于运行环境，在封装这一层去判断。</p><p>这层封装做了这些事：</p><ol><li><p>如果在主应用里运行，则直接调用中间层提供的缓存数据，直接返回给子应用</p></li><li><p>如果子应用是单独在运行，则需要去调用相关的接口，拉取到数据，然后返回给子应用</p></li></ol><p>封装那一层做的事情，对子应用是无感的，子应用只管调封装之后的接口就行</p><h3 id="如何切换调试环境"><a href="#如何切换调试环境" class="headerlink" title="如何切换调试环境"></a>如何切换调试环境</h3><p>前面我们通过在vue-cli插件里做了一层封装，让子应用可以脱离主应用进行开发，但是难免有的时候是需要接入到主应用里进行调试的，那这个时候怎么办呢？</p><p>我们利用环境变量进行区分，vue-cli支持在项目的根目录下定义<code>.env.</code>开头的文件，可以直接在这些文件里写环境变量，</p><p>在开发子应用的时候，只要在<code>.env.local</code>里配置上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RISHIQING_SINGLE_SPA=false # 可配置为true，构建在主应用里调试需要的代码</span><br></pre></td></tr></table></figure><p>当<code>RISHIQING_SINGLE_SPA</code>为true的时候，就会构建出一个适合SystemJs引入的js包，这样方便在主应用里调试</p><p>当<code>RISHIQING_SINGLE_SPA</code>为false的时候，也是默认值，表示子应用需要独立开发</p><p>除了前面说的获取基础数据的方式不一样之外，这两种环境最大的区别就是，<code>RISHIQING_SINGLE_SPA</code>为true的时候，不会构建出html，而<code>RISHIQING_SINGLE_SPA</code>为false的时候，由于需要独立调试，则需要构建html。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，关于日事清的微前端实践先写到这里了，有很多章节其实是很复杂的，但是要在一篇文章里写完，还是有难度。微前端不是银弹，适合的才是最好的。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><h2 id="为什么没有共享基础库，比如vue-axios-vuex等"><a href="#为什么没有共享基础库，比如vue-axios-vuex等" class="headerlink" title="为什么没有共享基础库，比如vue, axios, vuex等?"></a>为什么没有共享基础库，比如vue, axios, vuex等?</h2><p>开始是有做相关开发的，但是在开发过程中，我们发现，不同的子应用，依赖的版本号会不同，如果强制统一，很容易出问题。但是这样也带来了一个问题，就是会增加代码体积。我们会在后面各子应用逐渐稳定之后，想办法进行复用</p><h2 id="项目拆分成微前端之后，如果进行代码管理？"><a href="#项目拆分成微前端之后，如果进行代码管理？" class="headerlink" title="项目拆分成微前端之后，如果进行代码管理？"></a>项目拆分成微前端之后，如果进行代码管理？</h2><p>微前端架构虽然给前端项目带来了更多可能性，但也带来了维护上的困难。就拿我上面提到的vue-cli插件，我们现在的子应用有十几个，一旦插件有更新，就得在十几个项目里进行更新，非常麻烦。后续我们可能会引入<a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a>再把所有微应用放到一个仓库里进行管理，来解决包的依赖问题。俗话说分久必合，合久必分，大概就是这个理吧。</p><h2 id="对这次重构有什么想说的？"><a href="#对这次重构有什么想说的？" class="headerlink" title="对这次重构有什么想说的？"></a>对这次重构有什么想说的？</h2><p>业务的发展是技术的助推剂，一切技术的更新都源于对业务场景的思考</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="微前端" scheme="https://nodepie.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
      <category term="singleSpa" scheme="https://nodepie.com/tags/singleSpa/"/>
    
      <category term="vue" scheme="https://nodepie.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>代码审查的正确姿势</title>
    <link href="https://nodepie.com/2018/05/29/code-review/"/>
    <id>https://nodepie.com/2018/05/29/code-review/</id>
    <published>2018-05-29T12:55:42.000Z</published>
    <updated>2020-03-02T13:18:31.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这是一个很久之前我就想在前端团队里推的一个事情，基于这么几个原因吧:</p><ol><li>一直以来，前端的代码审查都是我一个人在做，仅仅是关注大家对公共文件的修改，还有就是一些明显的逻辑问题，但其实大部分问题靠我一个人是发现不了的</li><li>我们自己总是容易陷入逻辑怪圈，在写代码的时候，很难发现自己的问题，但是看别人的代码的时候，往往比较挑剔，更容易发现别人的问题</li><li>促进我们的日常代码交流，吸收别人的优秀经验</li><li>当你知道某个人会审查你的代码的时候，你会更加严格要求自己</li><li>培养我们写出优秀代码的习惯，实现团队和个人的共同进步</li><li>我们需要更加关注代码的质量</li><li>Code Review可以有效的和重构相结合，给我们重构提供有力证据，推动我们进行重构工作</li></ol><h2 id="审查些什么"><a href="#审查些什么" class="headerlink" title="审查些什么"></a>审查些什么</h2><h3 id="审查清单"><a href="#审查清单" class="headerlink" title="审查清单"></a>审查清单</h3><p>如果你所在的团队和我们一样，也刚开始做Code Review，对代码审查到底应该审查些什么感到茫然，在网上搜了很多审查清单，发现非常零碎，也不知道哪些应该遵守，哪些不应该遵守。我的建议是，可以根据团队现有的开发情况，自己大概整理一份审查清单，也不用太完整，只要建立好完整的整理机制，在实施Code Review的过程中，自己总结提炼，以及修改维护之前的审查清单，这样在完善审查清单的过程中，也对健全团队的Code Review机制非常有帮助，让团队成员对新增的审查清单更加有认同感。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>到底要不要在代码审查的时候审查代码的格式，都各说不一。个人觉得代码格式不应该成为代码审查重要的关注点，格式问题，更多应该是靠开发者自己去发现解决，借eslint和sass-lint这类工具辅助，以及团队的代码规范，在提交审核之前就应该做到没有问题。代码审查本来就是为了审核功能的实现方式，代码的组织形式等等有没有更优解，但也不是说完全不关注，如果发现了格式问题，还是需要提出来。</p><h3 id="审查形式"><a href="#审查形式" class="headerlink" title="审查形式"></a>审查形式</h3><p>总体来说，代码审查有两种形式，小片段式和大规模式</p><h4 id="小片段式"><a href="#小片段式" class="headerlink" title="小片段式"></a>小片段式</h4><p>小片段式的代码审查，又称事前审查，是在代码合并到主分支之前就做的一种审查形式。如果发现了问题，在代码合并之前就会进行需改。这种形式可以直接在线上进行，代码提交者和审查者可完全线上进行交流。</p><h4 id="大规模式"><a href="#大规模式" class="headerlink" title="大规模式"></a>大规模式</h4><p>大规模式的代码审查，又称事后审查，团队可以每两个星期或者一个月组织一次大模块式的Code Review会议，大家在会上进行大规模的代码检视，提出问题并记录，之后可以以重构的方式来处理在会议上发现的问题.</p><h4 id="哪种形式更好"><a href="#哪种形式更好" class="headerlink" title="哪种形式更好"></a>哪种形式更好</h4><p>这两种形式各有各的好处，小片段式的方式让我们可以在审查较小代码量的情况下就能进行，并且可以在代码合并之前进行，这样可以提前发现一些bug，而大规模式可以几个人一起在会议上站在一个更高的层面去审核代码，彼此交流开发经验。我推荐是小片段式和大规模式相结合。</p><h3 id="怎么审查"><a href="#怎么审查" class="headerlink" title="怎么审查"></a>怎么审查</h3><h4 id="审查工具"><a href="#审查工具" class="headerlink" title="审查工具"></a>审查工具</h4><p>我们的代码管理用的github，github提供了非常棒的Code Review功能。利用github提供的pull request模板功能，让代码提交者根据这个模板去填写每次提交pull request需要的信息。另外github的markdown支持checkbox，我们可以把一些非常重要的，每次都需要检视的审查项列到模板里去，这样提交者就可以按照这个列表自己提前检查一遍，也可以减少审查者的工作。下面是我们现在用的一个模板<br><img src="pull_request_template.md.png" alt="pull request 模板"><br>前面6个checkbox，是提交者每次都必须自查一遍，然后打钩，这6个checkbox不打完钩，就不会进入正常的审查流程，最后一个checkbox是审查者在审查完了之后打钩，表示这个pull request没问题，可以进行合并。如果团队的代码审查和代码合并不是同一个人，那么负责合并的人可以在pull request列表里看到每个pull request的进度，如下图<br><img src="pull_request_item.png" alt="pull request item"><br>如果所有checkbox已经完成，表示这个pull request可以进行合并</p><h4 id="通知工具"><a href="#通知工具" class="headerlink" title="通知工具"></a>通知工具</h4><p>用了github，当然是用github强大的邮件通知功能了。为了防止常用邮箱的通知爆炸，可以专门注册一个邮箱来接收github的邮件通知。推荐使用网易邮箱客户端，它有邮件分类功能，可以做到只通知部分邮件，防止打扰。</p><h2 id="代码审查的一些心得"><a href="#代码审查的一些心得" class="headerlink" title="代码审查的一些心得"></a>代码审查的一些心得</h2><ol><li>作为审查者，你需要知道你在给谁review代码</li><li>每个pull request应该尽可能的小，这样才能快速且安全的review</li><li>开放心态，虚心接受别人提的意见，要么采纳，要么说出自己反驳的理由</li><li>我们是人，不是机器，是人就会犯错，很正常</li><li>对公共文件的修改需要加倍关注，这些代码一旦出问题，会导致严重的错误</li></ol><h2 id="附上我们团队代码审查的流程图"><a href="#附上我们团队代码审查的流程图" class="headerlink" title="附上我们团队代码审查的流程图"></a>附上我们团队代码审查的流程图</h2><p><img src="flow.svg" alt="流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="code review" scheme="https://nodepie.com/tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>前端技术之eslint初夜</title>
    <link href="https://nodepie.com/2015/11/03/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8Beslint%E5%88%9D%E5%A4%9C/"/>
    <id>https://nodepie.com/2015/11/03/前端技术之eslint初夜/</id>
    <published>2015-11-03T07:49:26.000Z</published>
    <updated>2020-03-02T11:25:34.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置ESLint"><a href="#配置ESLint" class="headerlink" title="配置ESLint:"></a>配置ESLint:</h3><ol><li><strong>Configuration Comments</strong> - use JavaScript comments to embed configuration information directly into a file</li><li><strong>Configuration Files</strong></li></ol><h3 id="几个可配置的参数"><a href="#几个可配置的参数" class="headerlink" title="几个可配置的参数"></a>几个可配置的参数</h3><ul><li><strong>Environments</strong> - 代码运行的环境,不同环境都有不同的默认配置。</li><li><strong>Globals</strong> - 在执行的时候需要的一些全局变量。</li><li><strong>Rules</strong> - 启用哪些规则，错误级别是什么。</li></ul><h3 id="定义js语言特性-ES5-ES6"><a href="#定义js语言特性-ES5-ES6" class="headerlink" title="定义js语言特性(ES5/ES6)"></a>定义js语言特性(ES5/ES6)</h3><blockquote><p>在<code>ecmaFeatures</code>属性里，定义相应的js特性</p></blockquote><ul><li>arrowFunctions - 箭头函数</li><li>binaryLiterals - enable binary literals</li><li>blockBindings - enable let and const (aka block bindings)</li><li>classes - enable classes</li><li>defaultParams - enable default function parameters</li><li>destructuring - enable destructuring</li><li>forOf - enable for-of loops</li><li>generators - enable generators</li><li>modules - enable modules and global strict mode</li><li>objectLiteralComputedProperties - enable computed object literal property names</li><li>objectLiteralDuplicateProperties - enable duplicate object literal properties in strict mode</li><li>objectLiteralShorthandMethods - enable object literal shorthand methods</li><li>objectLiteralShorthandProperties - enable object literal shorthand properties</li><li>octalLiterals - enable octal literals</li><li>regexUFlag - enable the regular expression u flag</li><li>regexYFlag - enable the regular expression y flag</li><li>restParams - enable the rest parameters</li><li>spread - enable the spread operator for arrays</li><li>superInFunctions - enable super references inside of functions</li><li>templateStrings - enable template strings</li><li>unicodeCodePointEscapes - enable code point escapes</li><li>globalReturn - allow return statements in the global scope</li><li>jsx - JSX</li><li>experimentalObjectRestSpread - enable support for the experimental object rest/spread properties (IMPORTANT: This is an experimental feature that may change significantly in the future. It’s recommended that you do not write rules relying on this functionality unless you are willing to incur maintenance cost when it changes.)</li></ul><p>示例代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ecmaFeatures"</span>: &#123;</span><br><span class="line">        <span class="attr">"blockBindings"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"forOf"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Specifying-Parser"><a href="#Specifying-Parser" class="headerlink" title="Specifying Parser"></a>Specifying Parser</h3>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;配置ESLint&quot;&gt;&lt;a href=&quot;#配置ESLint&quot; class=&quot;headerlink&quot; title=&quot;配置ESLint:&quot;&gt;&lt;/a&gt;配置ESLint:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Configuration
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术之怎么在chrome里批量下载base64图片</title>
    <link href="https://nodepie.com/2015/10/13/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%80%8E%E4%B9%88%E5%9C%A8chrome%E9%87%8C%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbase64%E5%9B%BE%E7%89%87/"/>
    <id>https://nodepie.com/2015/10/13/前端技术之怎么在chrome里批量下载base64图片/</id>
    <published>2015-10-13T12:10:41.000Z</published>
    <updated>2020-03-02T11:25:34.890Z</updated>
    
    <content type="html"><![CDATA[<p>新任务，在chrome里批量下载base64编码的图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes=<span class="built_in">window</span>.atob(base64Str.split(<span class="string">","</span>)[<span class="number">1</span>]);<span class="comment">//base64Str是base64编码的字符串</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length);</span><br><span class="line"><span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] = bytes.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Blob( [ab] , &#123;<span class="attr">type</span> : <span class="string">'image/png'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> url = url = URL.createObjectURL(image);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);<span class="comment">//这里建一个a标签，用于下面下载图片</span></span><br><span class="line">a.href = url;</span><br><span class="line">a.download = fileName;<span class="comment">//fileName是下载的图片名称</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">e.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">a.dispatchEvent(e);<span class="comment">//触发点击事件，开始下载</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;新任务，在chrome里批量下载base64编码的图片。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于ionic在ios9中出现的问题</title>
    <link href="https://nodepie.com/2015/10/13/%E5%85%B3%E4%BA%8Eionic%E5%9C%A8ios9%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/13/关于ionic在ios9中出现的问题/</id>
    <published>2015-10-13T12:02:36.000Z</published>
    <updated>2020-03-02T11:25:34.890Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>[$rootScope:infdig] 10 $digest() iterations reached. Aborting!</span><br><span class="line">Watchers fired in the last 5 iterations: []</span><br></pre></td></tr></table></figure><p>该问题会导致页面的路由出问题，导致页面之间的切换出现异常，鬼火了很久。</p><p>需下载补丁：</p><p><a href="https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js" target="_blank" rel="noopener">https://gist.githubusercontent.com/IgorMinar/863acd413e3925bf282c/raw/58efa6bad10af41761e866084cb34bca28c7aa9d/angular-ios9-uiwebview.patch.js</a></p><p>在app.js（启动js）中应用模块：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'ngIOS9UIWebViewPatch</span>'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端的工程问题和技术问题</title>
    <link href="https://nodepie.com/2015/10/06/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E5%92%8C%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://nodepie.com/2015/10/06/前端的工程问题和技术问题/</id>
    <published>2015-10-06T09:23:06.000Z</published>
    <updated>2020-03-02T11:25:34.890Z</updated>
    
    <content type="html"><![CDATA[<p>最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>做过前端开发一定时间的同学都知道，前端的难点主要集中在两点：工程问题和技术问题。工程问题主要涉及到一系列自动化的问题，比如自动化测试，自动化集成，自动化部署等等；技术问题主要针对前端具体的开发问题了，比如浏览器兼容，页面性能，按需加载等等。</p><p>博主到现在对这些问题也只是了解个皮毛，还需要在接下来的日子和各位同学们一起深入研究探讨。</p><p>之后关于工程方面的问题，都会以<code>前端工程之***</code>为题展开，而关于技术方面的问题，则会以<code>前端技术之***</code>为题展开。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近苦于一些业务压力，而我们团队的前端研发实力一直是个大问题，作为一个能吃苦耐劳的好学生，对于这种事的解决和提升，当然是想都没想就扛下来啦。说不定，这一系列的研究还真能成为一个专题。给后续进来的前端同学一个指导性的入门吧。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql地理空间使用</title>
    <link href="https://nodepie.com/2015/08/06/mysql%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/08/06/mysql地理空间使用/</id>
    <published>2015-08-06T03:17:49.000Z</published>
    <updated>2020-03-02T11:25:34.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat</p><h3 id="创建地理空间数据表"><a href="#创建地理空间数据表" class="headerlink" title="创建地理空间数据表"></a>创建地理空间数据表</h3><p>要使用空间索引，表的类型要选择成MyISAM,貌似表的默认类型就是这个，但是有时候还是需要手动去改。如图</p><p><img src="navicat-1.png" alt="数据表"></p><h3 id="创建地理空间字段"><a href="#创建地理空间字段" class="headerlink" title="创建地理空间字段"></a>创建地理空间字段</h3><p>在我使用的navicat版本里面，创建字段的时候，type一栏里并没有关于地理空间的类型，需要手动输入.常用的类型有：</p><ul><li>GEOMETRY</li><li>POINT</li><li>LINESTRING</li><li>POLYGON</li><li>MULTIPOINT</li><li>MULTILINESTRING</li><li>MULTIPOLYGON</li><li>MULTIPOLYGON</li></ul><h3 id="连接数据库需要注意"><a href="#连接数据库需要注意" class="headerlink" title="连接数据库需要注意"></a>连接数据库需要注意</h3><p>使用以下方式连接.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.31.202 -u root -p -D learndrive <span class="comment">#learndrive是数据库的名称</span></span><br></pre></td></tr></table></figure><h3 id="创建地理空间索引"><a href="#创建地理空间索引" class="headerlink" title="创建地理空间索引"></a>创建地理空间索引</h3><p>在navicat里面无法直接创建SPATIAL索引，需要到shell里用命令行创建.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SPATIAL INDEX sp_index ON site (location); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>连接上mysql之后，直接用上面的代码创建索引，很可能会报错（是对已有的表创建索引造成）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1416 (22003): Cannot get geometry object from data you send to the GEOMETRY field</span><br></pre></td></tr></table></figure><p>先把地理空间字段的值对边填一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `site` SET `location` = POINT( 0,0 ); <span class="comment">#site是表，location是空间字段</span></span><br></pre></td></tr></table></figure><p>然后再创建索引.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本文不对mysql的地理空间使用做深入剖析，只是针对这几天对其的使用做一个教程记录.本文的操作工具是navicat&lt;/p&gt;
&lt;h3
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.gitlab-ci.yml使用</title>
    <link href="https://nodepie.com/2015/07/09/gitlab-ci-yml%E4%BD%BF%E7%94%A8/"/>
    <id>https://nodepie.com/2015/07/09/gitlab-ci-yml使用/</id>
    <published>2015-07-09T02:48:50.000Z</published>
    <updated>2020-03-02T11:25:34.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>gitlab-ci</code>确实有点坑，为了使用它的runner自动执行<code>shell</code>，然后编译，折腾了一两天，最后发现，呵呵，问题就这样稀里糊涂被解决了.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在工程的根目录添加了<code>.gitlab-ci.yml</code>文件之后,gitlab-ci build的状态每次都是pending，各种搜google，各种stackoverflow，都找不到解决办法。</p><h3 id="gitlab-ci-yml文件内容"><a href="#gitlab-ci-yml文件内容" class="headerlink" title=".gitlab-ci.yml文件内容"></a>.gitlab-ci.yml文件内容</h3><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>最后实在没办法，把之前的runner删了，重新建了一个runner，在提示需要哪个通道的时候，选择shell。</p><h3 id="新建runner的脚本"><a href="#新建runner的脚本" class="headerlink" title="新建runner的脚本"></a>新建runner的脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~gitlab_ci_multi_runner</span><br><span class="line">gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. http://gitlab-ci.org:3000/ )</span><br><span class="line">https://ci.gitlab.org/</span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx</span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">docker</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">ruby:2.1</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but <span class="keyword">if</span> it<span class="string">'s running already the config should be automatically reloaded!</span></span><br></pre></td></tr></table></figure><h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2><p><img src="gitlab-ci.png" alt="Resize icon"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="gitlab,gitlab-ci" scheme="https://nodepie.com/tags/gitlab-gitlab-ci/"/>
    
  </entry>
  
</feed>
